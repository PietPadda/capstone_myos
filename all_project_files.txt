; Stage 1 Bootloader with embedded FAT12 BPB

org 0x7C00
bits 16

; --- FAT12 BIOS Parameter Block ---
; This structure is now part of our bootloader. fs.c will read this.
jmp short start_bootloader
nop

bpb_oem_name:           db 'MYOS    ' ; 8-byte OEM name
bpb_bytes_per_sector:   dw 512
bpb_sectors_per_cluster:db 1
bpb_reserved_sectors:   dw 150
bpb_num_fats:           db 2
bpb_root_dir_entries:   dw 224
bpb_total_sectors:      dw 2880  ; 2880 * 512 = 1.44MB
bpb_media_type:         db 0xF0  ; F0 for 1.44MB floppy
bpb_sectors_per_fat:    dw 9
bpb_sectors_per_track:  dw 18
bpb_num_heads:          dw 2
bpb_hidden_sectors:     dd 0
bpb_total_sectors_large:dd 0
drive_number:           db 0x80
_reserved:              db 1
ext_boot_signature:     db 0x29
volume_serial:          dd 0xdeadbeef
volume_label:           db 'MYOS BOOT '
fs_type:                db 'FAT12   '

; --- Bootloader Code ---
; The jmp at the top of the file brings us here.
start_bootloader:
    ; The BIOS provides the boot drive in DL. We must save it immediately.
    mov [boot_drive], dl

    ; Set up segments and stack for a clean 16-bit environment
    xor ax, ax
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, 0x7C00

    ; --- Load Stage 2 from Disk ---
        ; We will load 4 sectors starting from LBA 1 into memory at 0x5000.
    ; Stage 2 will be placed at LBA 1 by our build script.
    mov si, dap                 ; Point SI to our Disk Address Packet
    mov word [si + 4], 0x5000   ; Target buffer offset: 0x5000
    mov word [si + 6], 0x0000   ; Target buffer segment: 0x0000 (ES:BX -> 0x0000:5000 = 0x5000)
    mov dword [si + 8], 1       ; LBA Start = 1 (sector after this bootloader)

    mov ah, 0x42                ; BIOS Extended Read function
    mov dl, [boot_drive]        ; Use the saved drive number
    int 0x13
    jc disk_error

    ; --- Jump to Stage 2 ---
        ; Pass the boot drive number in DL for Stage 2 to use
    mov dl, [boot_drive]
    jmp 0x0000:0x5000

disk_error:
    mov si, msg_disk_error
print_error_loop:
    lodsb
    or al, al
    jz hang
    mov ah, 0x0E
    int 0x10
    jmp print_error_loop

hang:
    cli
    hlt

; --- DATA ---
boot_drive:     db 0
msg_disk_error: db 'Stage 1 read error!', 0

; Disk Address Packet (DAP) for the extended read call
dap:
    db 0x10, 0          ; Size of packet (16 bytes)
    dw 4                ; Sectors to read = 4
    dd 0                ; Buffer address (filled at runtime)
    dq 0                ; LBA start (filled at runtime)

; --- Boot Signature ---
times 510 - ($ - $$) db 0
dw 0xAA55; Stage 2 Bootloader
; This bootloader is loaded by Stage 1. It uses LBA to load the kernel,
; enters 32-bit protected mode, and then jumps to the kernel.

org 0x5000  ; We are loaded at 0x5000 by Stage 1
bits 16

GDT_CODE equ 0x08
GDT_DATA equ 0x10

start:
    ; Stage 1 passes the boot drive number in DL. We save it immediately.
    mov [boot_drive], dl

    ; Set up our own stack.
    mov sp, 0x7C00 ; Set stack pointer to a safe area below the original bootloader

    ; --- Load Kernel using modern LBA Extended Read ---
    ; Kernel is located starting at LBA 5 by our build script.
    mov si, dap                 ; Point SI to our Disk Address Packet
    mov word [si + 2], 64       ; Increase sectors to read to 64 (32KB)
    mov word [si + 4], 0x0000   ; Target buffer offset
    mov word [si + 6], 0x1000   ; Target buffer segment (ES:BX -> 0x1000:0000 = 0x10000)
    mov dword [si + 8], 5       ; LBA Start = 5 (after stage1 and stage2)

    mov ah, 0x42                ; BIOS Extended Read function
    mov dl, [boot_drive]        ; Use the saved drive number
    int 0x13
    jc disk_error

    ; --- Enter Protected Mode ---
    cli                         ; 1. Disable interrupts
    lgdt [gdt_descriptor]       ; 2. Load our GDT
    
    mov eax, cr0                ; 3. Set the PE bit in CR0 to enable protected mode
    or eax, 0x01
    mov cr0, eax

    ; CRITICAL: Reload all segment registers now that we are in protected mode.
    ; The far jump will only reload CS, but we need the others to be valid
    ; for a stable state.
    mov ax, GDT_DATA
    mov ds, ax
    mov es, ax
    mov ss, ax
    
    jmp GDT_CODE:start_32bit    ; 4. Far jump to flush the CPU pipeline

disk_error:
    mov si, msg_disk_error
print_error_loop:
    lodsb
    or al, al
    jz hang
    mov ah, 0x0E
    int 0x10
    jmp print_error_loop

hang:
    cli
    hlt

; =======================================================
; ### 32-BIT PROTECTED MODE CODE ###
; =======================================================
bits 32
start_32bit:
    ; Set up 32-bit segment registers
    mov ax, GDT_DATA
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax

    ; Set up the stack in a high memory area
    mov esp, 0x90000

    ; Jump to the kernel's entry point
    jmp 0x10000

; =======================================================
; ### DATA SECTION ###
; =======================================================
boot_drive:     db 0
msg_disk_error: db 'Stage 2 read error!', 0

; Disk Address Packet (DAP) for the extended read call
dap:
    db 0x10, 0
    dw 0        ; Number of sectors (filled at runtime)
    dd 0        ; Buffer address (filled at runtime)
    dq 0        ; LBA start (filled at runtime)

gdt_descriptor:
    dw gdt_end - gdt_start - 1 ; GDT limit
    dd gdt_start               ; GDT base

gdt_start:
    ; Null descriptor
    dq 0x0

    ; Code Segment Descriptor (base=0, limit=4GB, Ring 0)
    dw 0xFFFF    ; Limit (low)
    dw 0x0       ; Base (low)
    db 0x0       ; Base (mid)
    db 0x9A      ; Access (Present, Ring 0, Code, Exec/Read)
    db 0xCF      ; Granularity (4K pages, 32-bit)
    db 0x0       ; Base (high)

    ; Data Segment Descriptor (base=0, limit=4GB, Ring 0)
    dw 0xFFFF    ; Limit (low)
    dw 0x0       ; Base (low)
    db 0x0       ; Base (mid)
    db 0x92      ; Access (Present, Ring 0, Data, Read/Write)
    db 0xCF      ; Granularity (4K pages, 32-bit)
    db 0x0       ; Base (high)
gdt_end:// myos/include/kernel/exceptions.h

#ifndef EXCEPTIONS_H
#define EXCEPTIONS_H

#include <kernel/types.h>

// This struct defines the registers pushed onto the stack.
// The order MUST EXACTLY MATCH the push order in isr.asm.
typedef struct {
    // Pushed by us manually, , so they are at the top of the frame.
    uint32_t gs, fs, es, ds;
    
    // Pushed by the 'pusha' instruction
    uint32_t edi, esi, ebp, esp, ebx, edx, ecx, eax;

    // Pushed by our ISR stub (interrupt number and error code).
    uint32_t int_no, err_code;

    // Pushed by the processor automatically when an interrupt occurs.
    uint32_t eip, cs, eflags, useresp, ss;
} __attribute__((packed)) registers_t;

void fault_handler(registers_t *r);

#endif// myos/include/kernel/gdt.h

#ifndef GDT_H
#define GDT_H

#include <kernel/types.h>

// This function initializes the kernel's GDT.
void gdt_install();

// our public helper function
void gdt_set_gate(int32_t num, uint32_t base, uint32_t limit, uint8_t access, uint8_t gran);

#endif// myos/include/kernel/shell.h

#ifndef SHELL_H
#define SHELL_H

// Initializes the shell.
void shell_init();

// Handles a single character of input.
void shell_handle_input(char c);

void shell_run();
void restart_shell();

#endif// myos/include/kernel/string.h

#ifndef STRING_H
#define STRING_H

#include <kernel/types.h>

// Compares two strings. Returns 0 if they are equal.
int strcmp(const char* str1, const char* str2);
int atoi(const char* str);
void* memset(void* buf, int c, size_t n);
int memcmp(const void* s1, const void* s2, size_t n);
int toupper(int c);
size_t strlen(const char* str);

#endif// myos/include/kernel/elf.h

#ifndef ELF_H
#define ELF_H

#include <kernel/types.h>

#define ELF_MAGIC 0x464C457F // corresponds to "\x7FELF"

// ELF Header Structure
typedef struct {
    uint32_t magic;
    uint8_t  ident[12];
    uint16_t type;
    uint16_t machine;
    uint32_t version;
    uint32_t entry;
    uint32_t phoff;
    uint32_t shoff;
    uint32_t flags;
    uint16_t ehsize;
    uint16_t phentsize;
    uint16_t phnum;
    uint16_t shentsize;
    uint16_t shnum;
    uint16_t shstrndx;
} __attribute__((packed)) Elf32_Ehdr;

// Program Header Structure
typedef struct {
    uint32_t type;
    uint32_t offset;
    uint32_t vaddr;
    uint32_t paddr;
    uint32_t filesz;
    uint32_t memsz;
    uint32_t flags;
    uint32_t align;
} __attribute__((packed)) Elf32_Phdr;

// Program header types
#define PT_NULL    0
#define PT_LOAD    1
#define PT_DYNAMIC 2
#define PT_INTERP  3
#define PT_NOTE    4

#endif// myos/include/kernel/keyboard.h

#ifndef KEYBOARD_H
#define KEYBOARD_H

// Initializes the keyboard driver and registers its IRQ handler.
void keyboard_install();

// Reads a single character from the keyboard buffer, blocking if empty.
char keyboard_read_char();

#endif// myos/include/kernel/fs.h

#ifndef FS_H
#define FS_H

#include <kernel/types.h>

// This struct maps to the FAT12 BIOS Parameter Block (BPB) in the boot sector.
// It contains all the essential metadata about the filesystem.
typedef struct {
    uint8_t  jump_code[3];          // The x86 JMP instruction to the boot code.
    uint8_t  oem_name[8];           // A string identifying who formatted the disk.
    uint16_t bytes_per_sector;      // How many bytes in a sector (usually 512).
    uint8_t  sectors_per_cluster;   // How many sectors are in an allocation unit (a "cluster").
    uint16_t reserved_sectors;      // Number of sectors before the first FAT, including this one.
    uint8_t  num_fats;              // The number of File Allocation Tables (usually 2).
    uint16_t root_dir_entries;      // Maximum number of files in the root directory.
    uint16_t total_sectors;         // Total sectors on the disk (if < 65536).
    uint8_t  media_type;            // An old field describing the disk type.
    uint16_t sectors_per_fat;       // How many sectors each FAT occupies.
    uint16_t sectors_per_track;     // Part of the old CHS geometry.
    uint16_t num_heads;             // Part of the old CHS geometry.
    uint32_t hidden_sectors;        // Sectors before this partition begins.
    uint32_t total_sectors_large;   // Total sectors on the disk (used if total_sectors is 0).
} __attribute__((packed)) fat12_bpb_t;

// This struct defines the exact 32-byte layout of a single directory entry
// as it is stored on a FAT12/16/32 formatted disk.
typedef struct {
    uint8_t  name[8];              // 8-byte filename, padded with spaces.
    uint8_t  extension[3];         // 3-byte extension, padded with spaces.
    uint8_t  attributes;           // Bitmask of file attributes (e.g., Read-Only, Directory).
    uint8_t  reserved;             // Reserved for use by Windows NT.
    uint8_t  creation_time_tenths; // Timestamp for creation time (tenths of a second).
    uint16_t creation_time;        // Time file was created.
    uint16_t creation_date;        // Date file was created.
    uint16_t last_access_date;     // Date of last access.
    uint16_t first_cluster_high;   // High 16 bits of the start cluster (used in FAT32).
    uint16_t last_mod_time;        // Time of last modification.
    uint16_t last_mod_date;        // Date of last modification.
    uint16_t first_cluster_low;    // Low 16 bits of the file's starting cluster number.
    uint32_t file_size;            // The size of the file in bytes.
} __attribute__((packed)) fat_dir_entry_t;

// The main function to initialize the filesystem driver.
void init_fs();

// Finds a file in the root directory by its name.
fat_dir_entry_t* fs_find_file(const char* filename);

// Reads the contents of a file given its directory entry.
void* fs_read_file(fat_dir_entry_t* entry);

void fs_read_cluster(uint16_t cluster, uint8_t* buffer);
uint16_t fs_get_fat_entry(uint16_t cluster);

// Make the global BPB pointer visible to other modules
extern fat12_bpb_t* bpb;

#endif // FS_H// myos/include/kernel/io.h

#ifndef IO_H
#define IO_H

void port_byte_out(unsigned short port, unsigned char data);
unsigned char port_byte_in(unsigned short port);
void pic_remap(int offset1, int offset2); // remapping interrupt vectors func
unsigned short port_word_in(unsigned short port);

#endif// myos/include/kernel/vga.h

#ifndef VGA_H
#define VGA_H

#include <kernel/types.h> // to include uint32_t

void clear_screen();
void update_cursor(int row, int col);
void print_string(const char* str);
void print_hex(uint32_t n);
void print_char(char c);
void print_hex(uint32_t n);

#endif// myos/include/kernel/irq.h

#ifndef IRQ_H
#define IRQ_H

#include <kernel/types.h>
#include <kernel/exceptions.h> // For registers_t struct

void irq_install_handler(int irq, void (*handler)(registers_t *r));
void irq_uninstall_handler(int irq);
void irq_install();
void irq_handler(registers_t *r);

#endif// myos/include/kernel/idt.h
#ifndef IDT_H
#define IDT_H

#include <kernel/types.h>

// Defines a single entry in the Interrupt Descriptor Table (a "gate")
struct idt_entry_struct {
   uint16_t base_low;    // The lower 16 bits of the handler function's address
   uint16_t selector;    // The GDT code segment selector to use
   uint8_t  always0;     // This must always be zero
   uint8_t  flags;       // The gate type and attributes
   uint16_t base_high;   // The upper 16 bits of the handler function's address
} __attribute__((packed));


// Defines the structure for the IDT pointer, which is loaded using the 'lidt' instruction
struct idt_ptr_struct {
   uint16_t limit;       // The size of the IDT in bytes minus 1
   uint32_t base;        // The linear address where the IDT starts
} __attribute__((packed));

void idt_set_gate(uint8_t num, uint32_t base, uint16_t selector, uint8_t flags);
void idt_install();

#endif// myos/include/kernel/disk.h

#ifndef DISK_H
#define DISK_H

#include <kernel/types.h>

// Reads a 512-byte sector from the disk.
// lba: The linear block address of the sector.
// buffer: A pointer to a 512-byte buffer to store the data.
void read_disk_sector(uint32_t lba, uint8_t* buffer);

#endif// myos/include/kernel/memory.h

#ifndef MEMORY_H
#define MEMORY_H

#include <kernel/types.h>

void init_memory();
void* malloc(uint32_t size);
void free(void* ptr);

#endif// myos/include/kernel/types.h
#ifndef TYPES_H
#define TYPES_H

// Define fixed-width integer types for cross-platform compatibility
// Unsigned integer types
typedef unsigned char   uint8_t;
typedef unsigned short  uint16_t;
typedef unsigned int    uint32_t;
typedef unsigned long long uint64_t;

// Signed integer types
typedef signed char        int8_t;
typedef signed short       int16_t;
typedef signed int         int32_t;
typedef signed long long   int64_t;

// Standard size type, essential for memory operations
typedef uint32_t size_t;

// Definition for a null pointer constant
#define NULL ((void*)0)

#endif// myos/include/kernel/syscall.h

#ifndef SYSCALL_H
#define SYSCALL_H

#include <kernel/exceptions.h> // Include the header that defines registers_t

// Define a type for our system call handler functions
typedef void (*syscall_t)(registers_t *r);

void syscall_install();

#endif// myos/include/kernel/timer.h

#ifndef TIMER_H
#define TIMER_H

#include <kernel/types.h>

// Initializes the PIT and registers its IRQ handler.
void timer_install();
uint32_t timer_get_ticks(); // getter func
void sleep(uint32_t ms);

#endif// myos/include/kernel/cpu/process.h

#ifndef PROCESS_H
#define PROCESS_H

#define MAX_ARGS 16 // Define the constant here

void switch_to_user_mode(void* entry_point, void* stack_ptr); // takes  entry point AND user stack pointer
void exec_program(int argc, char* argv[]);

#endif// myos/include/kernel/cpu/tss.h

#ifndef TSS_H
#define TSS_H

#include <kernel/types.h>

// This struct defines the layout of a Task State Segment.
struct tss_entry_struct {
   uint32_t prev_tss;   // The previous TSS - if we used hardware task switching
   uint32_t esp0;       // The kernel stack pointer to switch to when coming from user mode
   uint32_t ss0;        // The kernel stack segment to switch to
   uint32_t esp1;       // Unused...
   uint32_t ss1;
   uint32_t esp2;
   uint32_t ss2;
   uint32_t cr3;
   uint32_t eip;
   uint32_t eflags;
   uint32_t eax;
   uint32_t ecx;
   uint32_t edx;
   uint32_t ebx;
   uint32_t esp;
   uint32_t ebp;
   uint32_t esi;
   uint32_t edi;
   uint32_t es;         // The value to load into ES when switching to this task
   uint32_t cs;         // The value to load into CS when switching to this task
   uint32_t ss;         // The value to load into SS when switching to this task
   uint32_t ds;         // The value to load into DS when switching to this task
   uint32_t fs;         // The value to load into FS when switching to this task
   uint32_t gs;         // The value to load into GS when switching to this task
   uint32_t ldt;        // The LDT segment selector to use with this task
   uint16_t reserved1;
   uint16_t iomap_base; // The I/O map base address
} __attribute__((packed));

// Add this extern declaration to make the global TSS instance visible
extern struct tss_entry_struct tss_entry;

void tss_install();

#endif// myos/userspace/programs/args.c

#include <syscall.h>

// function signature for our main entry point
void user_program_main(int argc, char* argv[]) {
    syscall_print("Program received arguments:\n");

    char buf[2] = {0}; // For printing numbers
    buf[0] = argc + '0';
    syscall_print("  argc: ");
    syscall_print(buf);
    syscall_print("\n");

    for (int i = 0; i < argc; i++) {
        syscall_print("  argv[");
        buf[0] = i + '0';
        syscall_print(buf);
        syscall_print("]: ");
        syscall_print(argv[i]);
        syscall_print("\n");
    }

    syscall_exit();
}// myos/userspace/programs/user_test.c

#include <syscall.h>

void user_program_main() {
    // The ELF loader now correctly loads the .rodata section,
    // so we can use a standard string literal.
    const char* message = "--- PRINT MSG FROM USER PROGRAM VIA SYSCALL LIBRARY  ---";

    // Call the kernel's print function via our syscall wrapper.
    syscall_print(message);

    // Loop forever
    while(1) {}
}// myos/userspace/programs/user_test.c

#include <syscall.h>

void user_program_main() {
    syscall_print("Press any key to echo it...");

    // Call the kernel to get a character (blocks until keypress)
    char c = syscall_getchar();

    // We need a small buffer to print the character
    char buffer[2] = {0};
    buffer[0] = c;

    // Call the kernel to print the character back
    syscall_print("You pressed: ");
    syscall_print(buffer);

    // Instead of looping forever, exit the program.
    syscall_exit();
}// myos/userspace/libc/include/syscall.h

#ifndef SYSCALL_H
#define SYSCALL_H

// A simple C wrapper for our "print" syscall.
// It uses inline assembly to load the registers and call int 0x80.
static inline void syscall_print(const char* message) {
    // EAX=1 for our print syscall
    // EBX=message pointer
    __asm__ __volatile__ ("int $0x80" : : "a"(1), "b"(message));
}

// Wrapper for the "getchar" syscall.
static inline char syscall_getchar() {
    char result;
    // EAX=2 for our getchar syscall. The kernel's return value will be in EAX.
    __asm__ __volatile__ (
        "int $0x80"
        : "=a"(result)  // Output: store the final value of EAX into 'result'.
        : "a"(2)        // Input: set EAX to 2 before the interrupt.
    );
    return result;
}

// Wrapper for the "exit" syscall. It does not return.
static inline void syscall_exit() {
    // EAX=3 for our exit syscall
    __asm__ __volatile__ ("int $0x80" : : "a"(3));
}

#endif/* myos/userspace/linker.ld */

ENTRY(user_program_main)
OUTPUT_FORMAT(elf32-i386)

SECTIONS {
    /* Programs will be loaded at 1MB */
    . = 0x100000;

    .text : {
        *(.text)
    }

    .data : {
        *(.data)
    }

    .rodata : {
        *(.rodata)
    }

    .bss : {
        *(.bss)
    }
}// myos/kernel/syscall.c

#include <kernel/syscall.h>
#include <kernel/vga.h>
#include <kernel/exceptions.h>  // registers_t definition
#include <kernel/keyboard.h>    // keyboard input
#include <kernel/timer.h>       // sleep()
#include <kernel/io.h>          // port_byte_out()
#include <kernel/shell.h>       // restart_shell()
#include <kernel/cpu/tss.h>     // tss_entry

#define MAX_SYSCALLS 32

// We need access to the TSS to get the kernel stack pointer.
extern struct tss_entry_struct tss_entry;

// A temporary global to track the stack we need to free.
extern void* current_user_stack;

// The system call dispatch table
static syscall_t syscall_table[MAX_SYSCALLS];

// Our first syscall: takes a pointer to a string in EBX and prints it.
static void sys_test_print(registers_t *r) {
    char* message = (char*)r->ebx;
    print_string(message);
    print_char('\n');
}

// Syscall 2: Read a character from the keyboard, blocking until a key is pressed.
static void sys_getchar(registers_t *r) {
    char c = keyboard_read_char();
    // The return value of a syscall is placed in the EAX register.
    r->eax = c;
}

// Syscall 3: Exit the current program and return to the shell.
static void sys_exit(registers_t *r) {
    // Clean up resources (the user stack).
    if (current_user_stack) {
        free(current_user_stack);
        current_user_stack = NULL;
    }

    // Prepare to return to the kernel shell instead of the user program.
    // We do this by modifying the stack frame that the `iret` instruction will use.
    r->eip = (uint32_t)restart_shell;
    r->cs = 0x08;      // Kernel Code Segment
    r->ss = 0x10;      // Kernel Stack Segment
    r->useresp = tss_entry.esp0;
    r->eflags = 0x202; // Interrupts enabled (IF = 1), plus a mandatory bit.
}

void syscall_install() {
    // Install the test print syscall at index 1
    syscall_table[1] = &sys_test_print;
    // Install the new getchar syscall at index 2
    syscall_table[2] = &sys_getchar;
    // Install the new exit syscall at index 3
    syscall_table[3] = &sys_exit;
}

// The main C-level handler for all system calls
void syscall_handler(registers_t *r) {
    // Get the syscall number from the EAX register
    uint32_t syscall_num = r->eax;

    // Check if the number is valid (and not 0)
    if (syscall_num > 0 && syscall_num < MAX_SYSCALLS && syscall_table[syscall_num] != 0) {
        // If it is, look up the handler in our table
        syscall_t handler = syscall_table[syscall_num];
        // And call it
        handler(r);
    } else {
        // Invalid syscall number, print an error
        print_string("Invalid syscall number: ");
        print_hex(syscall_num);
        print_char('\n');
    }
}// myos/kernel/fs/fs.c

#include <kernel/fs.h>
#include <kernel/disk.h>
#include <kernel/vga.h>
#include <kernel/memory.h>
#include <kernel/io.h>
#include <kernel/string.h> // For our new string functions

fat12_bpb_t* bpb; // make global
static uint8_t* fat_buffer;
static uint32_t data_area_start_sector;
uint8_t* root_directory_buffer; // global ie no static
uint32_t root_directory_size; // global ie no static

void init_fs() {
    // Read the BIOS Parameter Block (Sector 0)
    uint8_t* buffer = (uint8_t*)malloc(512);
    read_disk_sector(0, buffer);
    bpb = (fat12_bpb_t*)buffer;
    port_byte_out(0xE9, '1'); // BPB should be read now

    // Read the FAT into memory
    uint32_t fat_size_bytes = bpb->sectors_per_fat * bpb->bytes_per_sector;
    fat_buffer = (uint8_t*)malloc(fat_size_bytes);
    for (uint32_t i = 0; i < bpb->sectors_per_fat; i++) {
        read_disk_sector(bpb->reserved_sectors + i, fat_buffer + (i * bpb->bytes_per_sector));
    }

    // Calculate the location and size of the root directory
    uint32_t root_dir_start_sector = bpb->reserved_sectors + (bpb->num_fats * bpb->sectors_per_fat);
    root_directory_size = (bpb->root_dir_entries * sizeof(fat_dir_entry_t));
    uint32_t root_dir_size_sectors = root_directory_size / bpb->bytes_per_sector;
    if (root_directory_size % bpb->bytes_per_sector > 0) {
        root_dir_size_sectors++;
    }
    port_byte_out(0xE9, '2'); // Root directory parameters calculated

    // calc starting sector of data area
    data_area_start_sector = root_dir_start_sector + root_dir_size_sectors;

    // Read the entire root directory into a new buffer
    root_directory_buffer = (uint8_t*)malloc(root_dir_size_sectors * bpb->bytes_per_sector);
    port_byte_out(0xE9, '3'); // About to start reading root dir sectors
    for (uint32_t i = 0; i < root_dir_size_sectors; i++) {
        read_disk_sector(root_dir_start_sector + i, root_directory_buffer + (i * 512));
        port_byte_out(0xE9, '.'); // Print a dot for each sector read
    }
    port_byte_out(0xE9, '4'); // FINISHED filesystem init */
}

uint16_t fs_get_fat_entry(uint16_t cluster) {
    uint32_t fat_offset = cluster + (cluster / 2);
    uint16_t* fat16 = (uint16_t*)&fat_buffer[fat_offset];
    
    if (cluster % 2 == 0) {
        return *fat16 & 0x0FFF; // Even cluster
    } else {
        return *fat16 >> 4;     // Odd cluster
    }
}

void fs_read_cluster(uint16_t cluster, uint8_t* buffer) {
    uint32_t lba = data_area_start_sector + (cluster - 2);
    read_disk_sector(lba, buffer);
}

fat_dir_entry_t* fs_find_file(const char* filename) {
    char fat_name[12];
    memset(fat_name, ' ', 11);
    fat_name[11] = '\0'; // Not strictly necessary, but good practice

    // Convert filename to FAT 8.3 format
    int i = 0, j = 0;
    while (filename[i] && filename[i] != '.' && j < 8) {
        fat_name[j++] = toupper(filename[i++]);
    }
    if (filename[i] == '.') i++;
    j = 8;
    while (filename[i] && j < 11) {
        fat_name[j++] = toupper(filename[i++]);
    }

    // Search the directory
    for (uint32_t offset = 0; offset < root_directory_size; offset += sizeof(fat_dir_entry_t)) {
        fat_dir_entry_t* entry = (fat_dir_entry_t*)(root_directory_buffer + offset);

        if (entry->name[0] == 0x00) break;
        if ((uint8_t)entry->name[0] == 0xE5) continue;
        if ((entry->attributes & 0x0F) == 0x0F) continue; // LFN
        if (entry->attributes & 0x08) continue;           // Volume Label

        // Instead of one 11-byte comparison, do two separate ones.
        if (memcmp(fat_name, entry->name, 8) == 0 && memcmp(fat_name + 8, entry->extension, 3) == 0) {
            return entry; // We found it!
        }
    }

    return NULL; // File not found
}

void* fs_read_file(fat_dir_entry_t* entry) {
    uint32_t size = entry->file_size;
    if (size == 0) return malloc(1); // Handle empty files

    // Allocate enough space for the full clusters to prevent a buffer overflow.
    uint32_t bytes_per_cluster = bpb->sectors_per_cluster * bpb->bytes_per_sector;
    uint32_t num_clusters = (size + bytes_per_cluster - 1) / bytes_per_cluster;
    uint8_t* file_buffer = (uint8_t*)malloc(num_clusters * bytes_per_cluster);

    if (!file_buffer) {
        return NULL;
    }

    uint8_t* current_pos = file_buffer;
    uint16_t current_cluster = entry->first_cluster_low;

    // This loop is now safe because our buffer is large enough.
    while (current_cluster < 0xFF8) { // 0xFF8 is the End-of-Chain marker for FAT12
        fs_read_cluster(current_cluster, current_pos);
        current_pos += bytes_per_cluster;
        current_cluster = fs_get_fat_entry(current_cluster);
    }
    return file_buffer;
}// myos/kernel/kernel.c

// headers
#include <kernel/idt.h> // interrupt tables
#include <kernel/vga.h> // writing to screen
#include <kernel/io.h> // hardware comms
#include <kernel/keyboard.h> // Include our new keyboard driver header
#include <kernel/timer.h> // Include our new timer driver header
#include <kernel/shell.h> // shell for CLI
#include <kernel/memory.h> // heap memory allocation
#include <kernel/gdt.h> // kernel permanent GDT
#include <kernel/fs.h> // Filesystem driver for init_fs()
#include <kernel/cpu/tss.h> // Task-State Segment
#include <kernel/syscall.h> // User Mode Syscalls

// Helper for debug prints
static inline void outb(unsigned short port, unsigned char data) {
    __asm__ __volatile__("outb %0, %1" : : "a"(data), "Nd"(port));
}

void kmain() {
    outb(0xE9, 'S'); // Start of kmain

    // initiate dynamic mem allocation
    // Modules like TSS and FS depend on malloc() being ready
    init_memory(); 
    outb(0xE9, 'M'); // Memory initialized

     // Install the kernel's GDT
    gdt_install();
    outb(0xE9, 'G'); // GDT installed

    // Install the TSS right after the GDT
    tss_install(); 
    outb(0xE9, 't'); // TSS installed

    // Syscall install after TSS
    syscall_install();
    outb(0xE9, 's'); // Syscall installed

    // Remap the PIC first to get the hardware into a stable state.
    pic_remap(0x20, 0x28); // Master PIC at 0x20, Slave at 0x28
    outb(0xE9, 'P'); // PIC remapped

    // Now, install our Interrupt Service Routines and load the IDT.
    idt_install();
    outb(0xE9, 'I'); // IDT installed

    // Install the keyboard driver.
    keyboard_install();
    outb(0xE9, 'K'); // Keyboard installed

    // Install the timer driver.
    timer_install(); // Install our new timer driver
    outb(0xE9, 'T'); // Timer installed

    // clear the bios text
    clear_screen();

    // Initialize the filesystem driver. This must be done after memory
    // is initialized, as it uses malloc().
    init_fs();
    outb(0xE9, 'F'); // Filesystem Initialized

    // Initialize the shell
    shell_init();
    outb(0xE9, 's'); // Shell initialized

    // Enable interrupts! From this point on, the CPU will respond to hardware.
    __asm__ __volatile__ ("sti");
    outb(0xE9, '!'); // Interrupts enabled

    // Start the shell's main processing loop.
    // This function will only return if a program is launched.
    shell_run();
    outb(0xE9, 'r'); // Shell processing loop

    // If shell_run returns, a program is running.
    // The kernel should now enter an idle state.
    while (1) {
        __asm__ __volatile__("hlt");
    }
}; myos/kernel/kernel_entry.asm
bits 32

; Tell the assembler that these symbols are defined in another file (the linker script)
extern kmain, bss_start, bss_end

; Make '_start' visible to the linker
global _start

_start:
    ; --- Clear the .bss section ---
    ; This is critical for C code to work correctly, as it ensures
    ; all static/global variables are initialized to zero.
    mov edi, bss_start      ; Put the starting address of .bss into EDI
    mov ecx, bss_end        ; Put the ending address of .bss into ECX
    sub ecx, edi            ; ECX now holds the size of .bss in bytes
    add ecx, 3              ; Add 3 to handle sizes that aren't a multiple of 4
    shr ecx, 2              ; Divide by 4 to get the number of 4-byte chunks (dwords)

    xor eax, eax            ; Set EAX to 0, the value we want to write
    cld                     ; Clear the direction flag, so `stosd` increments EDI
    rep stosd               ; Write EAX to [EDI] and repeat ECX times

    ; The bootloader has already set up the segments and stack.
    ; We can now safely call our main C function.
    call kmain

    ; If kmain returns (which it shouldn't), hang the system.
    cli
hang:
    hlt
    jmp hang// myos/kernel/mm/memory.c

#include <kernel/memory.h>
#include <kernel/io.h>     // port_byte_out

// This symbol is defined by the linker script
extern uint32_t kernel_end;

// Define the header for each memory block
typedef struct block_header {
    size_t size;                // Size of the block
    struct block_header* next;  // Pointer to the next free block
} block_header_t;

// This pointer will be "bumped" forward as we allocate memory
static uint32_t heap_top;

// Head of our new free list
static block_header_t* free_list_head = NULL;

void init_memory() {
    // The heap starts right where the kernel binary ends
    heap_top = (uint32_t)&kernel_end;
    // free_list_head is now correctly zeroed by the .bss clearing code
}

void* malloc(uint32_t size) {
    if (size == 0) {
        return NULL;
    }

    // This new implementation uses a pointer-to-a-pointer to make
    // list manipulation cleaner and to avoid the compiler bug.
    block_header_t** link = &free_list_head;
    while (*link) {
        block_header_t* current = *link;
        if (current->size >= size) {
            // Found a block. Unlink it from the list.
            *link = current->next;
            return (void*)(current + 1);
        }
        // Move to the 'next' pointer of the current block
        link = &current->next;
    }

    // Align the heap_top to a 4-byte boundary before allocating
    if (heap_top % 4 != 0) {
        heap_top = (heap_top + 3) & ~3;
    }

    // No suitable block found, allocate a new one from the top of the heap
    size_t total_size = sizeof(block_header_t) + size;
    block_header_t* new_block = (block_header_t*)heap_top;
    heap_top += total_size;

    new_block->size = size;
    new_block->next = NULL; // Not on the free list

    return (void*)(new_block + 1); // Return pointer to the user area

}

void free(void* ptr) {
    if (!ptr) {
        return; // Do nothing if a null pointer is freed
    }

    // Get the header of the block being freed
    block_header_t* header = (block_header_t*)ptr - 1;

    // Add it to the front of the free list
    header->next = free_list_head;
    free_list_head = header;
}
// myos/kernel/lib/string.c

#include <kernel/string.h>
#include <kernel/types.h>

int strcmp(const char* str1, const char* str2) {
    while (*str1 && (*str1 == *str2)) {
        str1++;
        str2++;
    }
    return *(const unsigned char*)str1 - *(const unsigned char*)str2;
}

int atoi(const char* str) {
    int res = 0;
    for (int i = 0; str[i] != '\0'; ++i) {
        res = res * 10 + str[i] - '0';
    }
    return res;
}

void* memset(void* buf, int c, size_t n) {
    unsigned char* p = buf;
    while (n--) {
        *p++ = (unsigned char)c;
    }
    return buf;
}

int memcmp(const void* s1, const void* s2, size_t n) {
    const unsigned char* p1 = s1;
    const unsigned char* p2 = s2;
    while (n--) {
        if (*p1 != *p2) {
            return *p1 - *p2;
        }
        p1++;
        p2++;
    }
    return 0;
}

int toupper(int c) {
    if (c >= 'a' && c <= 'z') {
        return c - 'a' + 'A';
    }
    return c;
}

size_t strlen(const char* str) {
    size_t len = 0;
    while (str[len]) {
        len++;
    }
    return len;
}// myos/kernel/cpu/process.c

#include <kernel/cpu/process.h>
#include <kernel/cpu/tss.h>
#include <kernel/fs.h>      // For filesystem functions
#include <kernel/memory.h>  // For malloc/free
#include <kernel/vga.h>     // For printing error messages
#include <kernel/elf.h>     // ELF loader struc
#include <kernel/string.h> // For memcpy and strlen

// We'll use a global to track the current user stack.
// In a multitasking OS, this would be part of a process structure.
void* current_user_stack = NULL;

// We need to access our TSS entry defined in tss.c
extern struct tss_entry_struct tss_entry;

// This is the function that performs the context switch to user mode.
// It sets up the stack for the IRET instruction and jumps.
void switch_to_user_mode(void* entry_point, void* stack_ptr) {
    __asm__ __volatile__ (
        "cli;"                  // Disable interrupts.

        // Manually move arguments into specific, safe registers immediately.
        // This prevents the compiler from reusing them for other tasks.
        "mov %0, %%ecx;"        // Move entry_point into ECX.
        "mov %1, %%edx;"        // Move stack_ptr into EDX.

        // Set the user-mode data segments using a *different* register (EAX).
        "mov $0x23, %%ax;"
        "mov %%ax, %%ds;"
        "mov %%ax, %%es;"
        "mov %%ax, %%fs;"
        "mov %%ax, %%gs;"

        // Prepare the IRET stack frame using our safe registers.
        "pushl $0x23;"          // SS: The user-mode stack segment.
        "pushl %%edx;"          // ESP: The user's new stack pointer (from our safe EDX).
        "pushfl;"               // EFLAGS: Push the kernel's EFLAGS register (32-bit).
        "popl %%eax;"           // Pop EFLAGS into EAX for modification.
        "orl $0x200, %%eax;"    // Set the IF flag (bit 9) to enable interrupts.
        "pushl %%eax;"          // Push the modified EFLAGS.
        "pushl $0x1B;"          // CS: The user-mode code segment.
        "pushl %%ecx;"          // EIP: The program's entry point (from our safe ECX).
        "iret;"                 // Execute the jump to user mode.

        : /* no output operands */
        // Input operands: Tell GCC to place the C variables into any general-purpose register.
        : "r"(entry_point), "r"(stack_ptr)
        // Clobber list: Tell GCC we modified EAX, ECX, and EDX.
        : "eax", "ecx", "edx"
    );
}

#define USER_STACK_SIZE 4096 // 4KB stack for user programs

// This function finds an ELF executable on disk, loads it into memory,
// and starts it as a new user-mode process
void exec_program(int argc, char* argv[]) {
    // The program to run is now passed as the first argument in the list.
    // e.g., in "run args.elf hello", argv[1] is "args.elf"
    const char* filename = argv[1]; 
    if (!filename) {
        print_string("run: Missing filename.");
        return;
    }

    // Find the file on disk using our filesystem driver.
    fat_dir_entry_t* file_entry = fs_find_file(filename);
    if (!file_entry) {
        print_string("run: File not found: ");
        print_string(filename);
        return;
    }

    // Read the entire file into a temporary buffer in kernel memory
    uint8_t* file_buffer = (uint8_t*)fs_read_file(file_entry);
    if (!file_buffer) {
        print_string("run: Not enough memory to load program.\n");
        return;
    }

    // Cast the beginning of the buffer to an ELF header
    Elf32_Ehdr* header = (Elf32_Ehdr*)file_buffer;

    // Parse the ELF header and validate the magic number
    if (header->magic != ELF_MAGIC) {
        print_string("run: Not an ELF executable.\n");
        free(file_buffer);
        return;
    }

    // Locate the program header table using the offset from the main heade
    Elf32_Phdr* phdrs = (Elf32_Phdr*)(file_buffer + header->phoff);

    // Iterate through program headers
    for (int i = 0; i < header->phnum; i++) {
        Elf32_Phdr* phdr = &phdrs[i];

        // We only care about "loadable" segments.
        if (phdr->type == PT_LOAD) {
            // Copy the segment from the file buffer to its final virtual address.
            uint8_t* dest = (uint8_t*)phdr->vaddr;
            uint8_t* src = file_buffer + phdr->offset;
            for (uint32_t j = 0; j < phdr->filesz; j++) {
                dest[j] = src[j];
            }

            // Handle the .bss section (uninitialized data)
            // memsz might be > filesz. The difference is the .bss section.
            if (phdr->memsz > phdr->filesz) {
                uint32_t bss_size = phdr->memsz - phdr->filesz;
                uint8_t* bss_start = dest + phdr->filesz;
                memset(bss_start, 0, bss_size);
            }
        }
    }

    // Allocate a separate, aligned stack for the user program.
    void* user_stack = malloc(USER_STACK_SIZE);
    if (!user_stack) {
        print_string("run: Not enough memory for user stack.\n");
        free(file_buffer);
        return;
    }
    // Track the stack so we can free it on exit.
    current_user_stack = user_stack;

    // Use uint32_t for stack pointer arithmetic
    uint32_t user_stack_top = (uint32_t)user_stack + USER_STACK_SIZE;

    // Place argc/argv onto the user stack
    // Copy argument strings to the top of the stack
    char* argv_strings_user[MAX_ARGS];
    for (int i = 0; i < argc; i++) {
        user_stack_top -= (strlen(argv[i]) + 1);
        argv_strings_user[i] = (char*)user_stack_top;
        memcpy(argv_strings_user[i], argv[i], strlen(argv[i]) + 1);
    }

    // Align stack to 4 bytes
    user_stack_top &= ~0x3;

    // Push the argv array (pointers to the strings)
    char** argv_user;
    user_stack_top -= sizeof(char*) * (argc + 1); // +1 for NULL terminator
    argv_user = (char**)user_stack_top;
    for (int i = 0; i < argc; i++) {
        argv_user[i] = argv_strings_user[i];
    }
    argv_user[argc] = NULL; // The list is NULL-terminated

    // Push argc and a pointer to argv (the arguments for main)
    user_stack_top -= sizeof(char**);
    *((char***)user_stack_top) = argv_user;
    user_stack_top -= sizeof(int);
    *((int*)user_stack_top) = argc;

    // The program is now in memory, so we can free the temporary file buffer
    free(file_buffer);

    // Jump to the program's entry point specified in the ELF header
    // Cast the final stack pointer back to void* for the function call
    switch_to_user_mode((void*)header->entry, user_stack_top);

    // This code is now truly unreachable, but for good practice,
    // if it were to be reached, we'd clean up.
    free(user_stack);
    current_user_stack = NULL;
}

// myos/kernel/cpu/tss.c

#include <kernel/cpu/tss.h>
#include <kernel/gdt.h>      // For the gdt_set_gate function
#include <kernel/string.h>   // For memset
#include <kernel/memory.h>   // For malloc

// Our single, global TSS instance
struct tss_entry_struct tss_entry;

// Assembly function to load the TSS selector into the TR register
extern void tss_flush();

void tss_install() {
    uint32_t base = (uint32_t)&tss_entry;
    uint32_t limit = sizeof(tss_entry);

    // Add the TSS descriptor to the GDT. 0x05 is the 6th entry (index 5).
    // 0x89 is the access byte for a 32-bit TSS.
    gdt_set_gate(5, base, limit, 0x89, 0x40);

    memset(&tss_entry, 0, sizeof(tss_entry));

    // explicitly tell the CPU there is no I/O map (x86 requirement)
    tss_entry.iomap_base = sizeof(tss_entry);

    // allocate the stack on the heap
    uint32_t stack_size = 4096;
    void* stack = malloc(stack_size);

    // Set the kernel stack segment and pointer
    tss_entry.ss0  = 0x10; // Kernel Data Segment selector
    // The stack grows downwards. The top must be aligned. We enforce 16-byte alignment.
    tss_entry.esp0 = ((uint32_t)stack + stack_size) & ~0xF; // use the allocated stack

    // Load the TSS selector into the CPU's Task Register (TR)
    tss_flush();
}; myos/kernel/cpu/tss_flush.asm

bits 32
global tss_flush

tss_flush:
    ; The TSS selector is the 6th entry in the GDT, at offset 0x28 (5 * 8).
    ; The RPL bits (lowest 2) must be 0.
    mov ax, 0x28
    ltr ax
    ret// myos/kernel/cpu/irq.c

#include <kernel/irq.h>
#include <kernel/io.h>
#include <kernel/vga.h>

// Array of function pointers for handling custom IRQ handlers
static void *irq_routines[16] = {0};

// Install a custom handler for a given IRQ
void irq_install_handler(int irq, void (*handler)(registers_t *r)) {
    irq_routines[irq] = handler;
}

// Clear a handler for a given IRQ
void irq_uninstall_handler(int irq) {
    irq_routines[irq] = 0;
}

// The main IRQ handler, called from our assembly stub
void irq_handler(registers_t *r) {
    void (*handler)(registers_t *r);

    // Find the handler for this IRQ number
    handler = irq_routines[r->int_no - 32];
    if (handler) {
        handler(r);
    }

    // Send the EOI (End of Interrupt) signal to the PICs
    if (r->int_no >= 40) {
        port_byte_out(0xA0, 0x20); // Send EOI to slave PIC
    }
    port_byte_out(0x20, 0x20); // Send EOI to master PIC
}// myos/kernel/cpu/gdt.c

#include <kernel/gdt.h>
#include <kernel/types.h>

// GDT entry structure
struct gdt_entry_struct {
    uint16_t limit_low;
    uint16_t base_low;
    uint8_t  base_middle;
    uint8_t  access;
    uint8_t  granularity;
    uint8_t  base_high;
} __attribute__((packed));

// GDT pointer structure
struct gdt_ptr_struct {
    uint16_t limit;
    uint32_t base;
} __attribute__((packed));

// Our GDT will now have 6 entries
static struct gdt_entry_struct gdt_entries[6];
static struct gdt_ptr_struct   gdt_ptr;

// Assembly inline function to load the GDT
static inline void gdt_flush_inline(struct gdt_ptr_struct* gdt_ptr) {
    __asm__ __volatile__(
        "lgdt (%0)\n\t"
        "mov $0x10, %%ax\n\t" // 0x10 is our kernel data segment selector
        "mov %%ax, %%ds\n\t"
        "mov %%ax, %%es\n\t"
        "mov %%ax, %%fs\n\t"
        "mov %%ax, %%gs\n\t"
        "ljmp $0x08, $.flush\n\t" // 0x08 is the code segment selector
        ".flush:\n\t"
        : : "r"(gdt_ptr) : "ax");
}

// Helper function to create a GDT entry
void gdt_set_gate(int32_t num, uint32_t base, uint32_t limit, uint8_t access, uint8_t gran) {
    gdt_entries[num].base_low    = (base & 0xFFFF);
    gdt_entries[num].base_middle = (base >> 16) & 0xFF;
    gdt_entries[num].base_high   = (base >> 24) & 0xFF;

    gdt_entries[num].limit_low   = (limit & 0xFFFF);
    gdt_entries[num].granularity = ((limit >> 16) & 0x0F) | (gran & 0xF0);
    gdt_entries[num].access      = access;
}

// Main function to install the GDT with 6 Entries
void gdt_install() {
    gdt_ptr.limit = (sizeof(struct gdt_entry_struct) * 6) - 1;
    gdt_ptr.base  = (uint32_t)&gdt_entries;
    
    // Kernel Segments (Ring 0)
    gdt_set_gate(0, 0, 0, 0, 0);                // Null segment
    gdt_set_gate(1, 0, 0xFFFFFFFF, 0x9A, 0xCF); // Code segment (Ring 0)
    gdt_set_gate(2, 0, 0xFFFFFFFF, 0x92, 0xCF); // Data segment (Ring 0)

    // User Segments (Ring 3)
    gdt_set_gate(3, 0, 0xFFFFFFFF, 0xFA, 0xCF); // User Code
    gdt_set_gate(4, 0, 0xFFFFFFFF, 0xF2, 0xCF); // User Data

    // The TSS entry will be set up by tss_install()

    // Load our new GDT
    gdt_flush_inline(&gdt_ptr);
}// myos/kernel/cpu/idt.c

#include <kernel/idt.h>

// Forward-declarations for our 32 ISR stubs in isr.asm
extern void isr0(); extern void isr1(); extern void isr2(); extern void isr3(); 
extern void isr4(); extern void isr5(); extern void isr6(); extern void isr7(); 
extern void isr8(); extern void isr9(); extern void isr10(); extern void isr11(); 
extern void isr12(); extern void isr13(); extern void isr14(); extern void isr15(); 
extern void isr16(); extern void isr17(); extern void isr18(); extern void isr19(); 
extern void isr20(); extern void isr21(); extern void isr22(); extern void isr23(); 
extern void isr24(); extern void isr25(); extern void isr26(); extern void isr27(); 
extern void isr28(); extern void isr29(); extern void isr30(); extern void isr31();
extern void isr128(); // Our new syscall handler

// Forward-declarations for our 16 IRQ stubs in isr.asm
extern void irq0(); extern void irq1(); extern void irq2(); extern void irq3();
extern void irq4(); extern void irq5(); extern void irq6(); extern void irq7();
extern void irq8(); extern void irq9(); extern void irq10(); extern void irq11();
extern void irq12(); extern void irq13(); extern void irq14(); extern void irq15();

// Declare our IDT with 256 entries.
struct idt_entry_struct idt_entries[256];
struct idt_ptr_struct   idt_ptr;

// This is our new, self-contained function to load the IDT.
static inline void idt_load_inline(struct idt_ptr_struct* idt_ptr) {
    __asm__ __volatile__("lidt %0" : : "m"(*idt_ptr));
}

/**
 * Sets a single gate (entry) in the IDT.
 * @param num The interrupt number (0-255).
 * @param base The address of the interrupt handler function.
 * @param selector The GDT code segment selector to use.
 * @param flags The flags for this gate (e.g., present, priority).
 */
void idt_set_gate(uint8_t num, uint32_t base, uint16_t selector, uint8_t flags) {
    idt_entries[num].base_low    = base & 0xFFFF;
    idt_entries[num].base_high   = (base >> 16) & 0xFFFF;
    idt_entries[num].selector    = selector;
    idt_entries[num].always0     = 0;
    // We must uncomment the OR below when we add the interrupt handlers.
    idt_entries[num].flags       = flags /* | 0x60 */;
}

// Initializes the IDT and loads it.
void idt_install() {
    // Set the IDT pointer struct's values
    idt_ptr.limit = (sizeof(struct idt_entry_struct) * 256) - 1;
    idt_ptr.base  = (uint32_t)&idt_entries;

    // For now, clear the entire IDT by pointing all entries to nothing.
    // In later steps, we'll replace these with actual handlers.
    for (int i = 0; i < 256; i++) {
        idt_set_gate(i, 0, 0, 0);
    }
    
    // Use Trap Gate flags (0x8F) for CPU exceptions!
    idt_set_gate(0, (uint32_t)isr0, 0x08, 0x8F);
    idt_set_gate(1, (uint32_t)isr1, 0x08, 0x8F);
    idt_set_gate(2, (uint32_t)isr2, 0x08, 0x8F);
    idt_set_gate(3, (uint32_t)isr3, 0x08, 0x8F);
    idt_set_gate(4, (uint32_t)isr4, 0x08, 0x8F);
    idt_set_gate(5, (uint32_t)isr5, 0x08, 0x8F);
    idt_set_gate(6, (uint32_t)isr6, 0x08, 0x8F);
    idt_set_gate(7, (uint32_t)isr7, 0x08, 0x8F);
    idt_set_gate(8, (uint32_t)isr8, 0x08, 0x8F);
    idt_set_gate(9, (uint32_t)isr9, 0x08, 0x8F);
    idt_set_gate(10, (uint32_t)isr10, 0x08, 0x8F);
    idt_set_gate(11, (uint32_t)isr11, 0x08, 0x8F);
    idt_set_gate(12, (uint32_t)isr12, 0x08, 0x8F);
    idt_set_gate(13, (uint32_t)isr13, 0x08, 0x8F);
    idt_set_gate(14, (uint32_t)isr14, 0x08, 0x8F);
    idt_set_gate(15, (uint32_t)isr15, 0x08, 0x8F);
    idt_set_gate(16, (uint32_t)isr16, 0x08, 0x8F);
    idt_set_gate(17, (uint32_t)isr17, 0x08, 0x8F);
    idt_set_gate(18, (uint32_t)isr18, 0x08, 0x8F);
    idt_set_gate(19, (uint32_t)isr19, 0x08, 0x8F);
    idt_set_gate(20, (uint32_t)isr20, 0x08, 0x8F);
    idt_set_gate(21, (uint32_t)isr21, 0x08, 0x8F);
    idt_set_gate(22, (uint32_t)isr22, 0x08, 0x8F);
    idt_set_gate(23, (uint32_t)isr23, 0x08, 0x8F);
    idt_set_gate(24, (uint32_t)isr24, 0x08, 0x8F);
    idt_set_gate(25, (uint32_t)isr25, 0x08, 0x8F);
    idt_set_gate(26, (uint32_t)isr26, 0x08, 0x8F);
    idt_set_gate(27, (uint32_t)isr27, 0x08, 0x8F);
    idt_set_gate(28, (uint32_t)isr28, 0x08, 0x8F);
    idt_set_gate(29, (uint32_t)isr29, 0x08, 0x8F);
    idt_set_gate(30, (uint32_t)isr30, 0x08, 0x8F);
    idt_set_gate(31, (uint32_t)isr31, 0x08, 0x8F);

    // Use Interrupt Gate flags (0x8E) for IRQs!
    idt_set_gate(32, (uint32_t)irq0, 0x08, 0x8E);
    idt_set_gate(33, (uint32_t)irq1, 0x08, 0x8E);
    idt_set_gate(34, (uint32_t)irq2, 0x08, 0x8E);
    idt_set_gate(35, (uint32_t)irq3, 0x08, 0x8E);
    idt_set_gate(36, (uint32_t)irq4, 0x08, 0x8E);
    idt_set_gate(37, (uint32_t)irq5, 0x08, 0x8E);
    idt_set_gate(38, (uint32_t)irq6, 0x08, 0x8E);
    idt_set_gate(39, (uint32_t)irq7, 0x08, 0x8E);
    idt_set_gate(40, (uint32_t)irq8, 0x08, 0x8E);
    idt_set_gate(41, (uint32_t)irq9, 0x08, 0x8E);
    idt_set_gate(42, (uint32_t)irq10, 0x08, 0x8E);
    idt_set_gate(43, (uint32_t)irq11, 0x08, 0x8E);
    idt_set_gate(44, (uint32_t)irq12, 0x08, 0x8E);
    idt_set_gate(45, (uint32_t)irq13, 0x08, 0x8E);
    idt_set_gate(46, (uint32_t)irq14, 0x08, 0x8E);
    idt_set_gate(47, (uint32_t)irq15, 0x08, 0x8E);

    // Set the gate for our system call interrupt 0x80
    // The flags 0xEE mean: Present, Ring 3, 32-bit Trap Gate
    idt_set_gate(128, (uint32_t)isr128, 0x08, 0xEE);

    // Load the IDT using our new inline assembly function
    idt_load_inline(&idt_ptr);
}; myos/kernel/cpu/isr.asm
bits 32

%macro ISR_NOERRCODE 1
global isr%1
isr%1:
    cli
    push dword 0
    push dword %1
    jmp isr_common_stub
%endmacro

%macro ISR_ERRCODE 1
global isr%1
isr%1:
    cli
    push dword %1
    jmp isr_common_stub
%endmacro

; --- Define the 32 exception handlers ---
ISR_NOERRCODE 0  ; 0: Divide By Zero Exception
ISR_NOERRCODE 1  ; 1: Debug Exception
ISR_NOERRCODE 2  ; 2: Non Maskable Interrupt Exception
ISR_NOERRCODE 3  ; 3: Breakpoint Exception
ISR_NOERRCODE 4  ; 4: Into Detected Overflow Exception
ISR_NOERRCODE 5  ; 5: Out of Bounds Exception
ISR_NOERRCODE 6  ; 6: Invalid Opcode Exception
ISR_NOERRCODE 7  ; 7: No Coprocessor Exception
ISR_ERRCODE   8  ; 8: Double Fault Exception (with error code)
ISR_NOERRCODE 9  ; 9: Coprocessor Segment Overrun Exception
ISR_ERRCODE   10 ; 10: Bad TSS Exception (with error code)
ISR_ERRCODE   11 ; 11: Segment Not Present Exception (with error code)
ISR_ERRCODE   12 ; 12: Stack Fault Exception (with error code)
ISR_ERRCODE   13 ; 13: General Protection Fault Exception (with error code)
ISR_ERRCODE   14 ; 14: Page Fault Exception (with error code)
ISR_NOERRCODE 15 ; 15: Unassigned Exception
ISR_NOERRCODE 16 ; 16: Coprocessor Fault Exception
ISR_ERRCODE   17 ; 17: Alignment Check Exception (with error code)
ISR_NOERRCODE 18 ; 18: Machine Check Exception
ISR_NOERRCODE 19 ; 19: SIMD Fault Exception
; Interrupts 20-31 are reserved by Intel.
ISR_NOERRCODE 20
ISR_NOERRCODE 21
ISR_NOERRCODE 22
ISR_NOERRCODE 23
ISR_NOERRCODE 24
ISR_NOERRCODE 25
ISR_NOERRCODE 26
ISR_NOERRCODE 27
ISR_NOERRCODE 28
ISR_NOERRCODE 29
ISR_NOERRCODE 30
ISR_NOERRCODE 31

; --- Define the 16 IRQ handlers ---
%macro IRQ 2
global irq%1
irq%1:
    cli
    push dword  0
    push dword  %2  ; Push the interrupt number
    jmp irq_common_stub
%endmacro

; IRQs 0-15. Remember we remapped them to 32-47.
IRQ 0, 32   ; Timer
IRQ 1, 33   ; Keyboard
IRQ 2, 34   ; Cascade
IRQ 3, 35   ; COM2
IRQ 4, 36   ; COM1
IRQ 5, 37   ; LPT2
IRQ 6, 38   ; Floppy Disk
IRQ 7, 39   ; LPT1
IRQ 8, 40   ; CMOS real-time clock
IRQ 9, 41   ; Free for peripherals
IRQ 10, 42  ; Free for peripherals
IRQ 11, 43  ; Free for peripherals
IRQ 12, 44  ; PS2 Mouse
IRQ 13, 45  ; FPU
IRQ 14, 46  ; Primary ATA Hard Disk
IRQ 15, 47  ; Secondary ATA Hard Disk

; --- Define our System Call Handler ---
global isr128
isr128:
    cli
    push dword 0    ; Push a dummy error code for stack consistency
    push dword 128  ; Push the interrupt number
    jmp syscall_common_stub

; --- Common Assembly Stub ---
; All ISRs jump here after pushing their number and a (optional) error code
extern fault_handler ; This is our C-level handler
isr_common_stub:
    ; 1. Save the general purpose registers
    pusha

    ; Save the segment registers safely
    xor eax, eax  ; Clear the full EAX register to zero
    mov ax, ds    ; Move 16-bit DS into the low part (AX)
    push eax      ; Push the clean, 32-bit EAX

    xor eax, eax
    mov ax, es
    push eax

    xor eax, eax
    mov ax, fs
    push eax

    xor eax, eax
    mov ax, gs
    push eax

    ; 3. Load kernel segments for the C handler to use
    mov ax, 0x10  ; 0x10 is our kernel data segment selector
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; 4. Push a pointer to the register block and call the C handler
    push esp
    call fault_handler

    ; 5. Clean up the pushed pointer from the stack
    add esp, 4

    ; 6. Restore the original segment registers
    pop eax
    mov gs, ax
    pop eax
    mov fs, ax
    pop eax
    mov es, ax
    pop eax
    mov ds, ax

    ; 7. Restore general purpose registers
    popa

    ; 8. Clean up error code & interrupt number, and return
    add esp, 8
    iret

; --- Common IRQ Stub ---
extern irq_handler ; Our new C-level IRQ handler
irq_common_stub:
    ; Save general purpose registers
    pusha

    ; Save the segment registers safely
    xor eax, eax  ; Clear the full EAX register to zero
    mov ax, ds    ; Move 16-bit DS into the low part (AX)
    push eax      ; Push the clean, 32-bit EAX

    xor eax, eax
    mov ax, es
    push eax

    xor eax, eax
    mov ax, fs
    push eax

    xor eax, eax
    mov ax, gs
    push eax

    ; Load the kernel's data segment for C code
    mov ax, 0x10  ; 0x10 is our GDT data segment selector
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; Push a pointer to the registers and call the C handler
    push esp
    call irq_handler
    add esp, 4 ; Clean up the pushed pointer

    ; Restore original segment registers
    pop eax
    mov gs, ax
    pop eax
    mov fs, ax
    pop eax
    mov es, ax
    pop eax
    mov ds, ax

    ; Restore general purpose registers
    popa
    add esp, 8 ; Clean up the error code and interrupt number
    iret       ; Atomically restores EFLAGS (which re-enables interrupts) and returns.


; --- Common Syscall Stub ---
extern syscall_handler ;our new C-level syscall handler
syscall_common_stub:
    ; Save general purpose registers
    pusha

    ; Save the segment registers safely
    xor eax, eax  ; Clear the full EAX register to zero
    mov ax, ds    ; Move 16-bit DS into the low part (AX)
    push eax      ; Push the clean, 32-bit EAX

    xor eax, eax
    mov ax, es
    push eax

    xor eax, eax
    mov ax, fs
    push eax

    xor eax, eax
    mov ax, gs
    push eax

    ; Load the kernel's data segment for C code
    mov ax, 0x10  ; 0x10 is our GDT data segment selector
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; Push a pointer to the registers and call the C handler
    push esp
    call syscall_handler
    add esp, 4 ; Clean up the pushed pointer

    ; Restore original segment registers
    pop eax
    mov gs, ax
    pop eax
    mov fs, ax
    pop eax
    mov es, ax
    pop eax
    mov ds, ax

    ; Restore general purpose registers
    popa
    add esp, 8 ; Clean up the error code and interrupt number
    iret       ; Atomically restores EFLAGS and returns.// myos/kernel/cpu/exceptions.c

#include <kernel/exceptions.h>
#include <kernel/vga.h>

// Helper function to print the names of the set EFLAGS bits
static void print_eflags(uint32_t eflags) {
    print_string(" [ ");
    if (eflags & 0x1) print_string("CF ");
    if (eflags & 0x4) print_string("PF ");
    if (eflags & 0x10) print_string("AF ");
    if (eflags & 0x40) print_string("ZF ");
    if (eflags & 0x80) print_string("SF ");
    if (eflags & 0x200) print_string("IF ");
    if (eflags & 0x400) print_string("DF ");
    print_string("]");
}

// Helper function to dump a section of the stack
static void dump_stack(uint32_t *stack_ptr) {
    print_string("\n\n-- STACK DUMP --\n");
    for (int i = 0; i < 16; ++i) {
        uint32_t value = stack_ptr[i];
        print_hex((uint32_t)&stack_ptr[i]);
        print_string(": ");
        print_hex(value);
        print_string("\n");
    }
}

// C-level handler for all exceptions
void fault_handler(registers_t *r) {
    clear_screen();

    print_string("CPU EXCEPTION CAUGHT! -- SYSTEM HALTED\n\n");
    print_string("Interrupt Number: ");
    print_hex(r->int_no);
    print_string("\nError Code:       ");
    print_hex(r->err_code);
    print_string("\n\n-- REGISTER DUMP --\n");
    print_string("EAX: "); print_hex(r->eax); print_string("  EBX: "); print_hex(r->ebx);
    print_string("\nECX: "); print_hex(r->ecx); print_string("  EDX: "); print_hex(r->edx);
    print_string("\nESI: "); print_hex(r->esi); print_string("  EDI: "); print_hex(r->edi);
    print_string("\n\n-- SEGMENT DUMP --\n");
    print_string("CS:  "); print_hex(r->cs);  print_string("     DS:  "); print_hex(r->ds);
    print_string("\nSS:  "); print_hex(r->ss);
    print_string("\n\n-- CONTROL DUMP --\n");
    print_string("EIP: "); print_hex(r->eip); 
    print_string("\nEFLAGS: "); print_hex(r->eflags);
    print_eflags(r->eflags);

    // Dump the stack. We use r->useresp for the stack pointer at the time of the fault.
    dump_stack((uint32_t *)r->useresp);

    for (;;);
}// myos/kernel/drivers/io.c

#include <kernel/io.h>

#define PIC1_CMD  0x20
#define PIC1_DATA 0x21
#define PIC2_CMD  0xA0
#define PIC2_DATA 0xA1

// Writes a byte to the specified I/O port.
void port_byte_out(unsigned short port, unsigned char data) {
    __asm__ __volatile__("outb %0, %1" : : "a"(data), "Nd"(port));
}

// Reads a byte from the specified I/O port.
unsigned char port_byte_in(unsigned short port) {
    unsigned char result;
    __asm__ __volatile__("inb %1, %0" : "=a"(result) : "Nd"(port));
    return result;
}

unsigned short port_word_in(unsigned short port) {
    unsigned short result;
    __asm__("inw %1, %0" : "=a" (result) : "Nd" (port));
    return result;
}

/**
 * Remaps the PIC to use non-conflicting interrupt vectors.
 * @param offset1 Vector offset for master PIC (e.g., 0x20)
 * @param offset2 Vector offset for slave PIC (e.g., 0x28)
 */
void pic_remap(int offset1, int offset2) {
    // Save current masks
    unsigned char a1 = port_byte_in(PIC1_DATA);
    unsigned char a2 = port_byte_in(PIC2_DATA);

    // ICW1: Start the initialization sequence
    port_byte_out(PIC1_CMD, 0x11);
    port_byte_out(PIC2_CMD, 0x11);

    // ICW2: Set the vector offsets
    port_byte_out(PIC1_DATA, offset1);
    port_byte_out(PIC2_DATA, offset2);

    // ICW3: Configure chaining between master and slave
    port_byte_out(PIC1_DATA, 4);  // Tell Master PIC there is a slave at IRQ2
    port_byte_out(PIC2_DATA, 2);  // Tell Slave PIC its cascade identity

    // ICW4: Set 8086 mode
    port_byte_out(PIC1_DATA, 0x01);
    port_byte_out(PIC2_DATA, 0x01);

    // Restore saved masks
    port_byte_out(PIC1_DATA, a1);
    port_byte_out(PIC2_DATA, a2);
}// myos/kernel/drivers/keyboard.c

#include <kernel/keyboard.h>
#include <kernel/irq.h>
#include <kernel/io.h>
#include <kernel/shell.h>
#include <kernel/vga.h>

// New keyboard buffer
#define KBD_BUFFER_SIZE 256
static char kbd_buffer[KBD_BUFFER_SIZE];
static volatile uint32_t kbd_buffer_read_idx = 0;
static volatile uint32_t kbd_buffer_write_idx = 0;

// --- State and Character Maps ---
static volatile int shift_pressed = 0;

// Scancode set 1 for a US QWERTY keyboard layout - Normal
unsigned char kbd_us[128] = {
    0,  27, '1', '2', '3', '4', '5', '6', '7', '8',     // 0-9
    '9', '0', '-', '=', '\b', '\t', 'q', 'w', 'e', 'r', // 10-19
    't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\n', 0,   // 20-29
    'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';',  // 30-39 (0x1E='a')
    '\'', '`', 0, '\\', 'z', 'x', 'c', 'v', 'b', 'n',  // 40-49
    'm', ',', '.', '/', 0, '*', 0, ' ', 0, 0,           // 50-59
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                       // 60-69
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                       // 70-79
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                       // 80-89
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                       // 90-99
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                       // 100-109
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                       // 110-119
    0, 0, 0, 0, 0, 0, 0, 0                              // 120-127
};

// Scancode set 1 for a US QWERTY keyboard layout - Shifted
unsigned char kbd_us_shift[128] = {
    0,  27, '!', '@', '#', '$', '%', '^', '&', '*',     // 0-9
    '(', ')', '_', '+', '\b', '\t', 'Q', 'W', 'E', 'R', // 10-19
    'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', '\n', 0,   // 20-29
    'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':',  // 30-39 (0x1E='A')
    '"', '~', 0, '|', 'Z', 'X', 'C', 'V', 'B', 'N',    // 40-49
    'M', '<', '>', '?', 0, '*', 0, ' ', 0, 0,           // 50-59
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                       // 60-69
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                       // 70-79
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                       // 80-89
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                       // 90-99
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                       // 100-109
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                       // 110-119
    0, 0, 0, 0, 0, 0, 0, 0                              // 120-127
};

// The main keyboard handler function, called by our IRQ dispatcher.
static void keyboard_handler(registers_t *r) {
    unsigned char scancode = port_byte_in(0x60);

    // Handle a key release first
    if (scancode & 0x80) {
        // If a shift key was released, update the flag.
        if ((scancode & 0x7F) == 0x2A || (scancode & 0x7F) == 0x36) {
            shift_pressed = 0;
        }
        return; // Nothing more to do on key release.
    }

    // Handle a key press
    // If it's a shift key, update the flag and exit.
    if (scancode == 0x2A || scancode == 0x36) {
        shift_pressed = 1;
        return;
    }

    // If we're still here, it must be a normal character key.
    if (scancode < 128) {
        char character = shift_pressed ? kbd_us_shift[scancode] : kbd_us[scancode];
        
        if (character) {
            // Instead of calling the shell, add the character to our buffer
            if ((kbd_buffer_write_idx + 1) % KBD_BUFFER_SIZE != kbd_buffer_read_idx) {
                kbd_buffer[kbd_buffer_write_idx] = character;
                kbd_buffer_write_idx = (kbd_buffer_write_idx + 1) % KBD_BUFFER_SIZE;
            }
        }
    }
}

// The installation function that hooks the handler into the IRQ system.
void keyboard_install() {
    // Register `keyboard_handler` to be called when IRQ 1 is triggered.
    irq_install_handler(1, keyboard_handler);
}

// Blocks until a character is available and returns it.
char keyboard_read_char() {
    // Wait for a character to be available
    while (kbd_buffer_read_idx == kbd_buffer_write_idx) {
        //Atomically enable interrupts and then halt.
        // The CPU will wait here until the next interrupt (e.g., a keypress).
        __asm__ __volatile__("sti\n\thlt");
    }

    // Read the character from the buffer
    char c = kbd_buffer[kbd_buffer_read_idx];
    kbd_buffer_read_idx = (kbd_buffer_read_idx + 1) % KBD_BUFFER_SIZE;
    return c;
}// myos/kernel/drivers/vga.c

#include <kernel/vga.h>
#include <kernel/io.h>
#include <kernel/types.h>

// Define a static cursor position
static int cursor_row = 0;
static int cursor_col = 0;

// Define the VGA buffer as a global, constant pointer to a volatile memory region.
volatile unsigned short* const VGA_BUFFER = (unsigned short*)0xB8000;

// Clear the screen by filling it with spaces
void clear_screen() {
    int i;
    for (int i = 0; i < 80 * 25; i++) {
        VGA_BUFFER[i] = (unsigned short)' ' | 0x0F00;
    }
    cursor_row = 0;
    cursor_col = 0;
    update_cursor(cursor_row, cursor_col);
}

// Updates the VGA cursor's position.
void update_cursor(int row, int col) {
    unsigned short position = (row * 80) + col;

    // Send the high byte of the cursor position
    port_byte_out(0x3D4, 0x0E);
    port_byte_out(0x3D5, (unsigned char)(position >> 8));
    // Send the low byte of the cursor position
    port_byte_out(0x3D4, 0x0F);
    port_byte_out(0x3D5, (unsigned char)(position & 0xFF));
}

void print_char(char c) {
    // Handle backspace
    if (c == '\b') {
        // Only backspace if the cursor isn't at the very beginning.
        if (cursor_col > 0) {
            cursor_col--;
        } else if (cursor_row > 0) {
            cursor_row--;
            cursor_col = 79; // Move to the end of the previous line.
        }
        // Write a blank space to the current cursor position to 'erase' the char.
        VGA_BUFFER[(cursor_row * 80) + cursor_col] = ' ' | (0x0F << 8);

    // Handle newline
    } else if (c == '\n') {
        cursor_row++;
        cursor_col = 0;
    } else {
        // Handle a normal character.
        // The new way: Directly write the character 'c' with a white-on-black
        // attribute (0x0F). This is more stable than the old method.
        VGA_BUFFER[(cursor_row * 80) + cursor_col] = c | (0x0F << 8);
        cursor_col++;
    }

    // If we're at the end of the line, wrap to the next line.
    if (cursor_col >= 80) {
        cursor_col = 0;
        cursor_row++;
    }
    // scrolling logic when cursor_row >= 25
    if (cursor_row >= 25) {
        // Move the text of every line up by one row.
        for (int i = 0; i < 24 * 80; i++) {
            VGA_BUFFER[i] = VGA_BUFFER[i + 80];
        }

        // Clear the last line.
        for (int i = 24 * 80; i < 25 * 80; i++) {
            VGA_BUFFER[i] = ' ' | (0x0F << 8);
        }
        
        // Set the cursor to the beginning of the last line.
        cursor_row = 24;
    }

    // Update the hardware cursor's position.
    update_cursor(cursor_row, cursor_col);
}

void print_string(const char* str) {
    int i = 0;
    while (str[i] != '\0') {
        print_char(str[i]);
        i++;
    }
}

void print_hex(uint32_t n) {
    print_string("0x");
    // Loop through each of the 8 hex digits (nibbles)
    for (int i = 28; i >= 0; i -= 4) {
        // Get the 4 bits for this digit
        uint32_t nibble = (n >> i) & 0xF;
        // Convert the number (0-15) to its ASCII character ('0'-'9', 'A'-'F')
        char c = (nibble > 9) ? (nibble - 10 + 'A') : (nibble + '0');
        print_char(c);
    }
}// myos/kernel/drivers/timer.c

#include <kernel/timer.h>
#include <kernel/irq.h>
#include <kernel/io.h>
#include <kernel/vga.h> // For printing output

static volatile uint32_t tick = 0;

// The handler that is called on every timer interrupt (IRQ 0).
static void timer_handler(registers_t *r) {
    tick++; // This is all the handler should do
}

// Configures the PIT and installs the timer handler.
void timer_install() {
    // Install the handler for IRQ 0
    irq_install_handler(0, timer_handler);

    //  Configure the PIT
    uint32_t frequency = 100; // Target frequency in Hz
    uint32_t divisor = 1193180 / frequency;

    // Send the command byte to the PIT command port.
    // Command 0x36 means: Channel 0, Access lo/hi, Mode 3 (square wave).
    port_byte_out(0x43, 0x36);

    // Send the frequency divisor, low byte then high byte.
    port_byte_out(0x40, (uint8_t)(divisor & 0xFF));
    port_byte_out(0x40, (uint8_t)((divisor >> 8) & 0xFF));
}

// tick getter func
uint32_t timer_get_ticks() {
    return tick;
}

// delay tick func
void sleep(uint32_t milliseconds) {
    uint32_t start_tick = timer_get_ticks();
    // Our timer is at 100Hz, so 1 tick happens every 10ms.
    uint32_t ticks_to_wait = milliseconds / 10;

    // If the duration is very short, still wait for at least one tick.
    if (ticks_to_wait == 0) {
        ticks_to_wait = 1;
    }

    uint32_t end_tick = start_tick + ticks_to_wait;

    while (timer_get_ticks() < end_tick) {
        // This is the fix: Re-enable interrupts and then immediately halt.
        // The CPU will wait here until the next timer interrupt arrives.
        __asm__ __volatile__("sti\n\thlt");
    }
}// myos/kernel/drivers/disk.c

#include <kernel/disk.h>
#include <kernel/io.h> // for port_word_in

// A more robust helper function to wait for the disk to be ready.
static void wait_disk_ready() {
    // Wait until the controller is ready for a new command.
    // This checks that BSY (Bit 7) is 0 and RDY (Bit 6) is 1.
    while ((port_byte_in(0x1F7) & 0xC0) != 0x40) {
        // Loop and do nothing.
    }
}

void read_disk_sector(uint32_t lba, uint8_t* buffer) {
    port_byte_out(0xE9, 'A'); // START of disk read
    wait_disk_ready();

    // Wait for the drive to settle by reading the status port 4 times.
    // This is the "400ns delay".
    port_byte_in(0x1F7);
    port_byte_in(0x1F7);
    port_byte_in(0x1F7);
    port_byte_in(0x1F7);

    // Send drive select and highest LBA bits
    port_byte_out(0x1F6, 0xE0 | ((lba >> 24) & 0x0F));

    // Add a small delay after selecting the drive. This gives the
    // controller time to get ready for the rest of the command.
    port_byte_in(0x1F7);
    port_byte_in(0x1F7);
    port_byte_in(0x1F7);
    port_byte_in(0x1F7);

    // Send the number of sectors to read (1)
    port_byte_out(0x1F2, 1);

    // Send the LBA address bytes
    port_byte_out(0x1F3, (uint8_t)lba);
    port_byte_out(0x1F4, (uint8_t)(lba >> 8));
    port_byte_out(0x1F5, (uint8_t)(lba >> 16));
    
    // Send the READ SECTORS command
    port_byte_out(0x1F7, 0x20);
    port_byte_out(0xE9, 'B'); // Read command sent


    // A more robust wait loop that also checks for errors.
    while (1) {
        uint8_t status = port_byte_in(0x1F7);

        if (status & 0x01) { // Is Bit 0 (ERR) set?
            port_byte_out(0xE9, 'X'); // Print 'X' for ERROR
            // In a real OS, we'd read the error port and handle it.
            // For now, we just stop.
            return;
        }

        if (!(status & 0x80)) { // Is Bit 7 (BSY) clear?
            if (status & 0x08) { // Is Bit 3 (DRQ) set?
                // Yes, ready to read data!
                break;
            }
        }
    }
    port_byte_out(0xE9, 'C'); // Disk is ready (DRQ is set)

    // Read 256 words (512 bytes) from the data port into the buffer
    for (int i = 0; i < 256; i++) {
        ((uint16_t*)buffer)[i] = port_word_in(0x1F0);
    }
    port_byte_out(0xE9, 'D'); // FINISHED disk read

    // Reading the status port after a read command acknowledges the interrupt,
    // allowing the next command to be processed.
    port_byte_in(0x1F7);
    port_byte_out(0xE9, 'E'); // debug
}// myos/kernel/shell.c

#include <kernel/shell.h>
#include <kernel/vga.h> // We need this for print_char
#include <kernel/string.h> // Needed for strcmp
#include <kernel/timer.h> // for tick getter
#include <kernel/io.h> // for port_byte_out
#include <kernel/memory.h> // for dynamic heap memory
#include <kernel/disk.h> // for disk sector read
#include <kernel/fs.h> // for FAT12 entries
#include <kernel/cpu/process.h> // User Mode Switch
#include <kernel/keyboard.h> // We need this for keyboard_read_char


#define PROMPT "PGOS> "
#define MAX_CMD_LEN 256

// Static variables to hold the command buffer state
static char cmd_buffer[MAX_CMD_LEN];
static int cmd_index = 0;

// Forward-declaration for our command processor
void process_command();

// Initialize the shell.
void shell_init() {
    cmd_index = 0; // Reset command index on shell restart
    print_string(PROMPT);
}

// Handles a single character of input.
void shell_handle_input(char c) {
    if (c == '\n') {
        print_char(c); // Echo the newline
        cmd_buffer[cmd_index] = '\0';
        process_command();
    } else if (c == '\b') {
        if (cmd_index > 0) {
            cmd_index--;
            print_char(c); // Echo backspace
        }
    } else if (cmd_index < MAX_CMD_LEN - 1) {
        cmd_buffer[cmd_index++] = c;
        print_char(c); // Echo the character
    }
}

// The main loop for the shell.
void shell_run() {
    while (1) {
        char c = keyboard_read_char();
        shell_handle_input(c);
    }
}

// cleanly restart the shell after a program exits.
void restart_shell() {
    // We are now the main thread of execution.
    // Re-initialize the shell and enter its main loop.
    shell_init(); 
    shell_run();  
}

// This function processes the completed command. 
void process_command() {
    // Trim leading whitespace
    char* start = cmd_buffer;
    while (*start == ' ') start++;

    // Parse the command line into argc and argv
    int argc = 0;
    char* argv[MAX_ARGS];
    char* current = start;

    while (*current && argc < MAX_ARGS) {
        argv[argc++] = current;
        // Find the next space or the end of the string
        while (*current && *current != ' ') {
            current++;
        }
        // If we found a space, null-terminate it to end the argument
        if (*current) {
            *current++ = '\0';
            // Skip any other spaces
            while (*current == ' ') current++;
        }
    }

    // Handle empty or only-whitespace commands
    if (argc == 0) {
        cmd_index = 0;
        print_string("\n");
        print_string(PROMPT);
        return;
    }

    // Command Handling
    print_string("\n");

    // help command
    if (strcmp(argv[0], "help") == 0) {
        print_string("Available commands:\n  help - Display this message\n  cls  - Clear the screen\n  uptime  - Shows OS running time\n  reboot  - Reset the OS\n  memtest  - Allocate, free then recycle memory\n  cat  - Reads .txt file contents (needs arg)\n  disktest  - Read LBA19 (root dir)\n  sleep  - Stops OS for X ticks\n  ls  - List files in root dir\n  dump  - Dump the first 128b of root dir buffer\n  run  - Run user mode program\n\n");

    // cls command
    } else if (strcmp(argv[0], "cls") == 0) {
        clear_screen();

    // uptime command
    } else if (strcmp(argv[0], "uptime") == 0) {
        // Our timer is set to 100Hz, so 100 ticks = 1 second
        print_string("Uptime (seconds): ");
        print_hex(timer_get_ticks() / 100);

    // reboot command
    } else if (strcmp(argv[0], "reboot") == 0) {
        print_string("Rebooting system...");
        // Send the reboot command to the keyboard controller
        port_byte_out(0x64, 0xFE);

    // memtest command
    } else if (strcmp(argv[0], "memtest") == 0) {
        print_string("Allocating block A (16 bytes)...");
        void* block_a = malloc(16);
        print_string("\n  A is at: "); print_hex((uint32_t)block_a);

        print_string("\nAllocating block B (1024 bytes)...");
        void* block_b = malloc(1024);
        print_string("\n  B is at: "); print_hex((uint32_t)block_b);

        print_string("\nFreeing block A...");
        free(block_a);

        print_string("\nAllocating block C (8 bytes)...");
        void* block_c = malloc(8);
        print_string("\n  C is at: "); print_hex((uint32_t)block_c);
        print_string("\n(Note: C should have the same address as A)");

    // cat command
    } else if (strcmp(argv[0], "cat") == 0) {
        if (argc > 1) {
            fat_dir_entry_t* file_entry = fs_find_file(argv[1]);
            if (file_entry) {
                uint8_t* buffer = (uint8_t*)fs_read_file(file_entry);
                if (buffer) {
                    for (uint32_t i = 0; i < file_entry->file_size; i++) {
                        print_char(buffer[i]);
                    }
                    // NOTE: We don't free(buffer) yet since we haven't written free()
                }
            } else {
                print_string("File not found: ");
                print_string(argv[1]);
            }
        } else {
            print_string("Usage: cat <filename>");
        }

    // disktest command
    } else if (strcmp(argv[0], "disktest") == 0) {
        print_string("Reading LBA 19 (root dir)...\n");

        // Allocate a 512-byte buffer for the sector data
        uint8_t* buffer = (uint8_t*)malloc(512);

        // Read sector 19, which should be the start of the root directory
        read_disk_sector(19, buffer);

        // Print the first 32 bytes (the first directory entry)
        print_string("First 32 bytes: ");
        for (int i = 0; i < 32; i++) {
            print_hex(buffer[i]);
            print_char(' ');
        }
        // Note: We don't free the buffer because we haven't written free() yet!

    // sleep command
    } else if (strcmp(argv[0], "sleep") == 0) {
        if (argc > 1) {
            int ms = atoi(argv[1]);
            print_string("Sleeping for ");
            print_string(argv[1]);
            print_string("ms...");
            sleep(ms);
        } else {
            print_string("Usage: sleep <milliseconds>");
        }

    // ls command
    } else if (strcmp(argv[0], "ls") == 0) {
        port_byte_out(0xE9, 'E'); // Entered 'ls' command handler
        // These labels are defined in fs.c
        extern uint8_t* root_directory_buffer;
        extern uint32_t root_directory_size;

        print_string("Name      Ext  Attr  Size\n");
        print_string("---------------------------\n");

        // Loop through every 32-byte entry in the root directory
        for (uint32_t i = 0; i < root_directory_size; i += 32) {
            fat_dir_entry_t* entry = (fat_dir_entry_t*)(root_directory_buffer + i);

            // Stop if we've reached the end of the directory list
            if (entry->name[0] == 0x00) {
                break;
            }
            // Skip deleted files
            if (entry->name[0] == 0xE5) {
                continue;
            }

            // Skip Long Filename entries which have a special attribute
            if ((entry->attributes & 0x0F) == 0x0F) {
                continue;
            }
            port_byte_out(0xE9, 'F'); // Found a valid file entry to list

            // Skip the Volume Label entry
            if (entry->attributes & 0x08) {
                continue;
            }

            // Print the 8.3 filename
            for (int j = 0; j < 8; j++) print_char(entry->name[j]);
            print_string("  ");
            for (int j = 0; j < 3; j++) print_char(entry->extension[j]);

            // Print attributes and size
            print_string("  0x"); print_hex(entry->attributes);
            print_string("  ");  print_hex(entry->file_size);
            print_string("\n");
        }
        port_byte_out(0xE9, 'G'); // Finished 'ls' command handler

    // dump command
    } else if (strcmp(argv[0], "dump") == 0) {
        extern uint8_t* root_directory_buffer;
        print_string("\nRoot Directory Buffer Dump:\n");
        for (int i = 0; i < 128; i++) { // Print the first 128 bytes
            print_hex(root_directory_buffer[i]);
            print_char(' ');
        }

    // run command
    } else if (strcmp(argv[0], "run") == 0) {
        if (argc > 1) {
            exec_program(argc, argv);
        } else {
            print_string("Usage: run <filename>");
        }
    
    // invalid command
    } else if (cmd_index > 0) { // Only show error for non-empty commands
        print_string("Unknown command: ");
        print_string(cmd_buffer);
        print_string("\n");
    }
    
    // Reset for the next command and print a new prompt.
    // This is only reached for built-in commands that don't launch a program.
    cmd_index = 0;

    // Only print a newline for spacing if the command wasn't "cls".
    if (strcmp(argv[0], "cls") != 0) {
        print_string("\n");
    }

    print_string(PROMPT);
}
/* myos/kernel/linker.ld */
ENTRY(_start)

SECTIONS {
    . = 0x10000; /* Kernel starts at 1MB */

    .text : {
        *(.text)
    }

    .rodata : {
        *(.rodata)
    }

    .data : {
        *(.data)
    }

    bss_start = .;
    .bss : {
        *(.bss)
    }
    bss_end = .;
    kernel_end = .;

    /* This section prevents the "executable stack" warning and cleans up output */
    /DISCARD/ : {
        *(.note.GNU-stack)
        *(.eh_frame)
    }
}# myos/Makefile

# --- Variables ---
BUILD_DIR := build
QEMU_CMD := qemu-system-i386
QEMU_OPTS := -hda $(BUILD_DIR)/os_image.bin -debugcon stdio

# --- Source Files ---
# Find all .c and .asm files within the kernel directory and its subdirectories
KERNEL_SRC_DIRS := $(shell find kernel -type d)
KERNEL_C_SRC    := $(foreach dir,$(KERNEL_SRC_DIRS),$(wildcard $(dir)/*.c))
KERNEL_ASM_SRC  := $(foreach dir,$(KERNEL_SRC_DIRS),$(wildcard $(dir)/*.asm))
# Manually specify bootloader sources
STAGE1_SRC := boot/stage1.asm
STAGE2_SRC := boot/stage2.asm
# User program sources
USER_PROGRAM_C_SRC := $(wildcard userspace/programs/*.c)

# --- Object Files ---
# Map source files to object files in the build directory, preserving paths
STAGE1_OBJ := $(BUILD_DIR)/boot/stage1.bin
STAGE2_OBJ := $(BUILD_DIR)/boot/stage2.bin
KERNEL_C_OBJ   := $(patsubst %.c,$(BUILD_DIR)/%.o,$(KERNEL_C_SRC))
KERNEL_ASM_OBJ := $(patsubst %.asm,$(BUILD_DIR)/%.o,$(KERNEL_ASM_SRC))
ALL_KERNEL_OBJS := $(KERNEL_C_OBJ) $(filter-out $(BUILD_DIR)/kernel/cpu/gdt_load.o, $(KERNEL_ASM_OBJ))
# The final ELF file for the user program, not a flat binary
USER_PROGRAM_ELFS := $(patsubst userspace/programs/%.c,$(BUILD_DIR)/userspace/programs/%.elf,$(USER_PROGRAM_C_SRC))

# --- Final Binaries ---
KERNEL_ELF := $(BUILD_DIR)/kernel.elf
KERNEL_BIN := $(BUILD_DIR)/kernel.bin
DISK_IMAGE := $(BUILD_DIR)/os_image.bin

# --- Toolchain Flags ---
ASM := nasm
ASM_FLAGS := -f elf32 -F dwarf
CC := gcc
CFLAGS := -m32 -ffreestanding -nostdlib -fno-pie -fno-stack-protector -g -c -Iinclude -Iuserspace/libc/include
LD := ld
LDFLAGS := -m elf_i386 -T kernel/linker.ld -nostdlib
OBJCOPY := objcopy

# --- Build Targets ---
.PHONY: all clean run debug

# Default target: build everything
all: $(DISK_IMAGE)

# The disk image now depends on our user program ELF
# Rule to create the final disk image
$(DISK_IMAGE): $(STAGE1_OBJ) $(STAGE2_OBJ) $(KERNEL_BIN) $(USER_PROGRAM_ELFS)
	@echo "--> Creating blank disk image..."
	dd if=/dev/zero of=$@ bs=512 count=2880 >/dev/null 2>&1
	@echo "--> Formatting disk with FAT12..."
	mkfs.fat -F 12 $@ >/dev/null 2>&1
	@echo "--> Installing Stage 1 bootloader..."
	dd if=$(STAGE1_OBJ) of=$@ conv=notrunc >/dev/null 2>&1
	@echo "--> Copying test file to disk image..."
	mcopy -i $@ test_files/test.txt ::
	@echo "--> Copying user programs to disk image..."
	mcopy -i $@ $(USER_PROGRAM_ELFS) ::
	@echo "--> Installing Stage 2 bootloader..."
	dd if=$(STAGE2_OBJ) of=$@ seek=1 conv=notrunc >/dev/null 2>&1
	@echo "--> Installing kernel..."
	dd if=$(KERNEL_BIN) of=$@ seek=5 conv=notrunc >/dev/null 2>&1

# Rule to link all kernel objects into a single ELF file
# Note: We must ensure kernel_entry.o is first in the link order.
KERNEL_ENTRY_OBJ := $(BUILD_DIR)/kernel/kernel_entry.o
OTHER_KERNEL_OBJS := $(filter-out $(KERNEL_ENTRY_OBJ), $(ALL_KERNEL_OBJS))
$(KERNEL_ELF): $(KERNEL_ENTRY_OBJ) $(OTHER_KERNEL_OBJS)
	$(LD) $(LDFLAGS) -o $@ $^
	@echo "Kernel linked: $@"

# Rule to extract the raw binary from the ELF file
$(KERNEL_BIN): $(KERNEL_ELF)
	$(OBJCOPY) -O binary $< $@
	@echo "Kernel extracted to binary: $@"
	@echo -n "Kernel size: "; stat -c %s $@

# --- Generic Build Rules ---

# Rule for any C object file
$(BUILD_DIR)/%.o: %.c
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) $< -o $@

# Rule for any ASM object file
$(BUILD_DIR)/%.o: %.asm
	@mkdir -p $(dir $@)
	$(ASM) $(ASM_FLAGS) $< -o $@

# Rule for stage 1 bootloader
$(STAGE1_OBJ): $(STAGE1_SRC)
	@mkdir -p $(dir $@)
	$(ASM) -f bin $< -o $@

# Rule for stage 2 bootloader
$(STAGE2_OBJ): $(STAGE2_SRC)
	@mkdir -p $(dir $@)
	$(ASM) -f bin $< -o $@

# Rule for user programs from C source
$(BUILD_DIR)/userspace/programs/%.elf: userspace/programs/%.c
	@mkdir -p $(dir $@)
	# Step 1: Compile C source to an object file
	$(CC) $(CFLAGS) $< -o $(@:.elf=.o)
	# Step 2: Link the object file into a final ELF executable
	$(LD) -m elf_i386 -T userspace/linker.ld -nostdlib -o $@ $(@:.elf=.o)
	@echo "User program ELF built: $@"

# --- Utility Targets ---
run: all
	$(QEMU_CMD) $(QEMU_OPTS)

debug: all
	$(QEMU_CMD) -S -gdb tcp::1234 $(QEMU_OPTS)

clean:
	@echo "Cleaning build directory..."
	rm -rf $(BUILD_DIR)