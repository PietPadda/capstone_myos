; myos/boot/bootloader.asm
; this is the absolute minimal bootloader.
; it will run in 16-bit real mode when loaded by the BIOS.

org 0x7C00              ; tells NASM that code will be loaded by BIOS at physical address 0x7C00.
bits 16                 ; instructs NASM  generate 16-bit instruction opcodes for Real Mode.

; --- GDT Constants (Labels for our Memory Map) ---
; Each "segment" (chunk of memory) in our map will have an "entry".
; Each entry is 8 bytes big. These numbers are just positions within the map.
GDT_NULL equ 0       ; Label for the very first (empty) entry in our map
GDT_CODE equ 0x8     ; Label for the entry describing where our program code is
GDT_DATA equ 0x10    ; Label for the entry describing where our program data is

start:                  ; label marks very first instruction bootloader will execute
    mov bh, dl      ; BIOS stores boot drive in DL, save it in BH

    ; setup segment registers.
    xor ax, ax      ; Set AX to zero
    mov ds, ax      ; Set Data Segment to 0
    mov es, ax      ; Set Extra Segment to 0
    mov ss, ax      ; Set Stack Segment to 0

    ; set up the Stack Pointer (SP).
    ; stack grows downwards in x86. By starting SP at 0x7C00 (our segment base),
    ; stack will grow into memory *before* our code (addresses < 0x7C00),
    ; preventing it from overwriting the bootloader's own instructions (which are at 0x7C00 to 0x7DFF).
    mov sp, 0x7C00      ; Set SP to the beginning of our segment (offset 0x7C00 from its base, which is 0x7C0).

    ; --- Set video mode to 80x25 text mode ---
    mov ah, 0x00
    mov al, 0x03  ; Mode 3 is 80x25 16-color text mode.
    int 0x10      ; this is the command that sets the video mode!

    ; --- Print our welcome message to the screen ---
    mov si, msg_welcome ; Point SI to our message string.
    mov ah, 0x0E        ; Use BIOS teletype function.
print_loop:
    lodsb               ; Load byte from [DS:SI] into AL, advance SI.
    or al, al           ; Check if AL is zero (end of string).
    jz done_printing    ; If zero, we are done.
    int 0x10            ; Call BIOS video interrupt to print.
    jmp print_loop      ; Loop to the next character.

done_printing:
    ; --- Reset disk system (INT 13h, AH=00h) ---
    mov ah, 0x00        ; Function 00h = Reset Disk System
    mov dl, bh          ; Use the boot drive number we saved in BH
    int 0x13            ; Call BIOS disk service
    jc disk_error       ; If Carry Flag is set, reset failed.

    ; --- Load Kernel from Disk ---
    mov ax, 0x1000      ; Set ES to 0x1000. ES:BX will be our destination address.
    mov es, ax
    xor bx, bx          ; Set BX to 0. Full address is ES:BX = 0x1000:0x0000 = 0x10000.

    mov ah, 0x02        ; BIOS read sectors function
    mov al, 10          ; Read X sectors (4KB), enough for a small kernel
    mov ch, 0x00        ; Cylinder 0
    mov cl, 0x02        ; Sector 2 (where our kernel starts)
    mov dh, 0x00        ; Head 0
    mov dl, bh          ; Use the boot drive number saved from the BIOS
    int 0x13            ; Call BIOS disk service

    jc disk_error       ; If the read failed, the Carry Flag is set. Jump to an error handler.

    cmp al, 10           ; Compare AL (sectors actually read) with X (sectors requested)
    jne disk_error      ; If they're Not Equal, jump to our error handler

    mov al, '1'
    out 0xE9, al ; Checkpoint 1: Disk read OK

    ; --- Enable A20 Line (Keyboard Controller Method) ---
    call a20_wait_input   ; Wait for controller to be ready
    mov al, 0xAD          ; Command to disable the keyboard
    out 0x64, al

    call a20_wait_input
    mov al, 0xD0          ; Command to read the output port
    out 0x64, al

    call a20_wait_output  ; Wait for data to be ready
    in al, 0x60           ; Read the data
    push eax              ; Save it

    call a20_wait_input
    mov al, 0xD1          ; Command to write to the output port
    out 0x64, al

    call a20_wait_input
    pop eax               ; Get the original value back
    or al, 2              ; Set bit 1 (the A20 bit)
    out 0x60, al          ; Write it back to the controller

    call a20_wait_input
    mov al, 0xAE          ; Command to re-enable the keyboard
    out 0x64, al

    call a20_wait_input

    mov al, '2'
    out 0xE9, al ; Checkpoint 2: A20 enabled

    ; --- Disable interrupts (CLI) ---
    cli

    ; --- Load GDT (LGDT) ---
    ; This instruction loads the base address and limit of our GDT
    ; into the CPU's special 'GDTR' register. The CPU now knows
    ; where to find our memory map for Protected Mode.
    lgdt [cs:gdt_descriptor]

    mov al, '3'
    out 0xE9, al ; Checkpoint 3: GDT loaded

    ; --- Set Protected Mode Enable (PE) bit in CR0 register ---
    ; This is the instruction that officially switches the CPU from
    ; 16-bit Real Mode to 32-bit Protected Mode.
    mov eax, cr0         ; Read the current value of CR0 into EAX (a 32-bit register)
    or eax, 0x1          ; Set the lowest bit (bit 0), which is the PE (Protected Mode Enable) bit
    mov cr0, eax         ; Write the modified value back to CR0

    mov al, '4'
    out 0xE9, al ; Checkpoint 4: Protected Mode enabled

    ; --- Far Jump Directly to the Kernel's Entry Point ---
    ; This is now the final action of the bootloader.
    mov al, 'J'
    out 0xE9, al ; Checkpoint 5: About to Jump
    jmp GDT_CODE:0x10000

disk_error:
    mov ah, 0x0E    ; BIOS teletype function
    mov al, 'X'     ; Character to print
    int 0x10        ; Print it
    ; Fall through to hang

hang:
    cli             ; Disable interrupts
    hlt             ; Halt the CPU
    jmp hang        ; Loop just in case

a20_wait_input:
    in al, 0x64
    test al, 2
    jnz a20_wait_input
    ret

a20_wait_output:
    in al, 0x64
    test al, 1
    jz a20_wait_output
    ret

; =======================================================
; Data Section
; All data used by the bootloader goes here.
; =======================================================

; --- GDT Pointer (for the CPU to find our GDT map) ---
; This special 6-byte structure tells the CPU:
; 1. The total size of our GDT map (minus 1).
; 2. The exact memory address where our GDT map starts.
gdt_descriptor:
    dw gdt_end - gdt_start - 1 ; The "size" of our GDT map (2 bytes)
    dd gdt_start               ; The "starting address" of our GDT map (4 bytes)

; --- Global Descriptor Table (GDT) - Our Memory Map ---
; This table defines how the CPU can access different chunks of memory.
gdt_start: ; This label marks the very beginning of our GDT map.
    ; 1. The "Null" Entry (Required Empty Slot) - always 8 bytes of zeros
    dq 0x0

    ; 2. Our "Code" Entry (for running program instructions) - 8 bytes
    ; This rule tells the CPU: "You can execute code from memory starting at address 0,
    ; all the way up to 4 Gigabytes. Treat this memory as 32-bit."
    dw 0xFFFF    ; Part of the "size" of this memory chunk
    dw 0x0       ; Part of the "starting address" of this memory chunk
    db 0x0       ; Another part of the "starting address"
    db 10011010b ; "Access" byte: describes how this memory can be used (e.g., executable)
    db 11001111b ; "Flags" and another part of the "size" (e.g., 32-bit, 4KB blocks)
    db 0x0       ; The last part of the "starting address"

    ; 3. Our "Data" Entry (for storing program data) - 8 bytes
    ; This rule tells the CPU: "You can read and write data from memory starting at address 0,
    ; all the way up to 4 Gigabytes. Treat this memory as 32-bit."
    dw 0xFFFF    ; Part of the "size" of this memory chunk
    dw 0x0       ; Part of the "starting address"
    db 0x0       ; Another part of the "starting address"
    db 10010010b ; "Access" byte: describes how this memory can be used (e.g., writable)
    db 11001111b ; "Flags" and another part of the "size" (e.g., 32-bit, 4KB blocks)
    db 0x0       ; The last part of the "starting address"
gdt_end: ; This label marks the end of our GDT map for now.

msg_welcome:
    db 'MyOS Bootloader: Loading Kernel...', 0

; --------------------------------------------------------------------------
; Boot Signature (Crucial for BIOS)
; --------------------------------------------------------------------------
times 510 - ($ - $$) db 0 ; fill rest of 512-byte sector with zeros
                          ; ($ - $$) calculates current size from 'org 0x7C00'
                          ; ensures boot sector is precisely 512 bytes long before the signature
dw 0xAA55                 ; Boot signature: 0xAA55 must be at offset 510 (0x1FE) of boot sector
                          ; BIOS verifies signature to consider the sector "bootable"

// myos/kernel/exceptions.h

#ifndef EXCEPTIONS_H
#define EXCEPTIONS_H

#include "types.h"

// A struct which defines the registers we pushed onto the stack in isr.asm.
typedef struct {
   uint32_t ds;                                      // Pushed by us
   uint32_t edi, esi, ebp, esp, ebx, edx, ecx, eax;  // Pushed by pusha
   uint32_t err_code, int_no;                        // Pushed by our ISR stub (err_code first!)
   uint32_t eip, cs, eflags, useresp, ss;            // Pushed by the processor automatically
} __attribute__((packed)) registers_t;               // No padding GCC attribute

void isr_install();
void fault_handler(registers_t *r); // Changed to take a pointer

#endif// myos/kernel/io.c

#include "io.h"

#define PIC1_CMD  0x20
#define PIC1_DATA 0x21
#define PIC2_CMD  0xA0
#define PIC2_DATA 0xA1

// Writes a byte to the specified I/O port.
void port_byte_out(unsigned short port, unsigned char data) {
    __asm__ __volatile__("outb %0, %1" : : "a"(data), "Nd"(port));
}

// Reads a byte from the specified I/O port.
unsigned char port_byte_in(unsigned short port) {
    unsigned char result;
    __asm__ __volatile__("inb %1, %0" : "=a"(result) : "Nd"(port));
    return result;
}

/**
 * Remaps the PIC to use non-conflicting interrupt vectors.
 * @param offset1 Vector offset for master PIC (e.g., 0x20)
 * @param offset2 Vector offset for slave PIC (e.g., 0x28)
 */
void pic_remap(int offset1, int offset2) {
    // Save current masks
    unsigned char a1 = port_byte_in(PIC1_DATA);
    unsigned char a2 = port_byte_in(PIC2_DATA);

    // ICW1: Start the initialization sequence
    port_byte_out(PIC1_CMD, 0x11);
    port_byte_out(PIC2_CMD, 0x11);

    // ICW2: Set the vector offsets
    port_byte_out(PIC1_DATA, offset1);
    port_byte_out(PIC2_DATA, offset2);

    // ICW3: Configure chaining between master and slave
    port_byte_out(PIC1_DATA, 4);  // Tell Master PIC there is a slave at IRQ2
    port_byte_out(PIC2_DATA, 2);  // Tell Slave PIC its cascade identity

    // ICW4: Set 8086 mode
    port_byte_out(PIC1_DATA, 0x01);
    port_byte_out(PIC2_DATA, 0x01);

    // Restore saved masks
    port_byte_out(PIC1_DATA, a1);
    port_byte_out(PIC2_DATA, a2);
}// myos/kernel/idt.c

#include "idt.h"

// Forward-declarations for our 32 ISR stubs in isr.asm
extern void isr0(); extern void isr1(); extern void isr2(); extern void isr3(); 
extern void isr4(); extern void isr5(); extern void isr6(); extern void isr7(); 
extern void isr8(); extern void isr9(); extern void isr10(); extern void isr11(); 
extern void isr12(); extern void isr13(); extern void isr14(); extern void isr15(); 
extern void isr16(); extern void isr17(); extern void isr18(); extern void isr19(); 
extern void isr20(); extern void isr21(); extern void isr22(); extern void isr23(); 
extern void isr24(); extern void isr25(); extern void isr26(); extern void isr27(); 
extern void isr28(); extern void isr29(); extern void isr30(); extern void isr31();

// Declare our IDT with 256 entries.
struct idt_entry_struct idt_entries[256];
struct idt_ptr_struct   idt_ptr;

// This is our new, self-contained function to load the IDT.
static inline void idt_load_inline(struct idt_ptr_struct* idt_ptr) {
    __asm__ __volatile__("lidt %0" : : "m"(*idt_ptr));
}

/**
 * Sets a single gate (entry) in the IDT.
 * @param num The interrupt number (0-255).
 * @param base The address of the interrupt handler function.
 * @param selector The GDT code segment selector to use.
 * @param flags The flags for this gate (e.g., present, priority).
 */
void idt_set_gate(uint8_t num, uint32_t base, uint16_t selector, uint8_t flags) {
    idt_entries[num].base_low    = base & 0xFFFF;
    idt_entries[num].base_high   = (base >> 16) & 0xFFFF;
    idt_entries[num].selector    = selector;
    idt_entries[num].always0     = 0;
    // We must uncomment the OR below when we add the interrupt handlers.
    idt_entries[num].flags       = flags /* | 0x60 */;
}

/**
 * Initializes the IDT and loads it.
 */
void idt_install() {
    // Set the IDT pointer struct's values
    idt_ptr.limit = (sizeof(struct idt_entry_struct) * 256) - 1;
    idt_ptr.base  = (uint32_t)&idt_entries;

    // For now, clear the entire IDT by pointing all entries to nothing.
    // In later steps, we'll replace these with actual handlers.
    for (int i = 0; i < 256; i++) {
        idt_set_gate(i, 0, 0, 0);
    }
    
    // Use Trap Gate flags (0x8F) for CPU exceptions!
    idt_set_gate(0, (uint32_t)isr0, 0x08, 0x8F);
    idt_set_gate(1, (uint32_t)isr1, 0x08, 0x8F);
    idt_set_gate(2, (uint32_t)isr2, 0x08, 0x8F);
    idt_set_gate(3, (uint32_t)isr3, 0x08, 0x8F);
    idt_set_gate(4, (uint32_t)isr4, 0x08, 0x8F);
    idt_set_gate(5, (uint32_t)isr5, 0x08, 0x8F);
    idt_set_gate(6, (uint32_t)isr6, 0x08, 0x8F);
    idt_set_gate(7, (uint32_t)isr7, 0x08, 0x8F);
    idt_set_gate(8, (uint32_t)isr8, 0x08, 0x8F);
    idt_set_gate(9, (uint32_t)isr9, 0x08, 0x8F);
    idt_set_gate(10, (uint32_t)isr10, 0x08, 0x8F);
    idt_set_gate(11, (uint32_t)isr11, 0x08, 0x8F);
    idt_set_gate(12, (uint32_t)isr12, 0x08, 0x8F);
    idt_set_gate(13, (uint32_t)isr13, 0x08, 0x8F);
    idt_set_gate(14, (uint32_t)isr14, 0x08, 0x8F);
    idt_set_gate(15, (uint32_t)isr15, 0x08, 0x8F);
    idt_set_gate(16, (uint32_t)isr16, 0x08, 0x8F);
    idt_set_gate(17, (uint32_t)isr17, 0x08, 0x8F);
    idt_set_gate(18, (uint32_t)isr18, 0x08, 0x8F);
    idt_set_gate(19, (uint32_t)isr19, 0x08, 0x8F);
    idt_set_gate(20, (uint32_t)isr20, 0x08, 0x8F);
    idt_set_gate(21, (uint32_t)isr21, 0x08, 0x8F);
    idt_set_gate(22, (uint32_t)isr22, 0x08, 0x8F);
    idt_set_gate(23, (uint32_t)isr23, 0x08, 0x8F);
    idt_set_gate(24, (uint32_t)isr24, 0x08, 0x8F);
    idt_set_gate(25, (uint32_t)isr25, 0x08, 0x8F);
    idt_set_gate(26, (uint32_t)isr26, 0x08, 0x8F);
    idt_set_gate(27, (uint32_t)isr27, 0x08, 0x8F);
    idt_set_gate(28, (uint32_t)isr28, 0x08, 0x8F);
    idt_set_gate(29, (uint32_t)isr29, 0x08, 0x8F);
    idt_set_gate(30, (uint32_t)isr30, 0x08, 0x8F);
    idt_set_gate(31, (uint32_t)isr31, 0x08, 0x8F);

    // Load the IDT using our new inline assembly function
    idt_load_inline(&idt_ptr);
}// myos/kernel/kernel.c

// headers
#include "idt.h"
#include "vga.h"
#include "io.h"

// Helper for debug prints
static inline void outb(unsigned short port, unsigned char data) {
    __asm__ __volatile__("outb %0, %1" : : "a"(data), "Nd"(port));
}

void kmain() {
    outb(0xE9, 'K'); // Checkpoint: kmain entered

    // Set up the IDT AND install the exception handlers
    /// Remap the PIC first to get the hardware into a stable state.
    pic_remap(0x20, 0x28); // Master PIC at 0x20, Slave at 0x28
    outb(0xE9, 'P'); // Checkpoint: PIC remapped

    // Now, install our Interrupt Service Routines and load the IDT.
    idt_install();
    outb(0xE9, 'I'); // Checkpoint: IDT installed

    // Clear the screen to start with a blank slate
    clear_screen();
    outb(0xE9, 'V'); // Checkpoint: VGA (clear_screen)
    
    // Print a new message
    char message[] = "Kernel Loaded! Code is now organized.";
    volatile unsigned short* vga_buffer = (unsigned short*)0xB8000;
    int j = 0;

    // --- Print the message from the stack array ---
    while (message[j] != '\0') {
        vga_buffer[j] = (unsigned short)message[j] | 0x0F00;
        j++;
    }

    // Move the cursor to the end of the message
    update_cursor(0, j);

    // Hang the CPU.
    while (1) {}
}; myos/kernel/isr.asm
bits 32

; This macro creates a stub for an ISR that does not push an error code
%macro ISR_NOERRCODE 1
[GLOBAL isr%1]
isr%1:
    cli          ; Disable interrupts
    push dword 0       ; Push a dummy error code (explicitly 32-bit)
    push dword %1      ; Push the interrupt number (explicitly 32-bit)
    jmp isr_common_stub
%endmacro

; This macro creates a stub for an ISR that DOES push an error code
%macro ISR_ERRCODE 1
[GLOBAL isr%1]
isr%1:
    cli          ; Disable interrupts
    push dword %1      ; Push the interrupt number (explicitly 32-bit)
    jmp isr_common_stub
%endmacro

; --- Define the 32 exception handlers ---
ISR_NOERRCODE 0  ; 0: Divide By Zero Exception
ISR_NOERRCODE 1  ; 1: Debug Exception
ISR_NOERRCODE 2  ; 2: Non Maskable Interrupt Exception
ISR_NOERRCODE 3  ; 3: Breakpoint Exception
ISR_NOERRCODE 4  ; 4: Into Detected Overflow Exception
ISR_NOERRCODE 5  ; 5: Out of Bounds Exception
ISR_NOERRCODE 6  ; 6: Invalid Opcode Exception
ISR_NOERRCODE 7  ; 7: No Coprocessor Exception
ISR_ERRCODE   8  ; 8: Double Fault Exception (with error code)
ISR_NOERRCODE 9  ; 9: Coprocessor Segment Overrun Exception
ISR_ERRCODE   10 ; 10: Bad TSS Exception (with error code)
ISR_ERRCODE   11 ; 11: Segment Not Present Exception (with error code)
ISR_ERRCODE   12 ; 12: Stack Fault Exception (with error code)
ISR_ERRCODE   13 ; 13: General Protection Fault Exception (with error code)
ISR_ERRCODE   14 ; 14: Page Fault Exception (with error code)
ISR_NOERRCODE 15 ; 15: Unassigned Exception
ISR_NOERRCODE 16 ; 16: Coprocessor Fault Exception
ISR_ERRCODE   17 ; 17: Alignment Check Exception (with error code)
ISR_NOERRCODE 18 ; 18: Machine Check Exception
ISR_NOERRCODE 19 ; 19: SIMD Fault Exception
; Interrupts 20-31 are reserved by Intel.
ISR_NOERRCODE 20
ISR_NOERRCODE 21
ISR_NOERRCODE 22
ISR_NOERRCODE 23
ISR_NOERRCODE 24
ISR_NOERRCODE 25
ISR_NOERRCODE 26
ISR_NOERRCODE 27
ISR_NOERRCODE 28
ISR_NOERRCODE 29
ISR_NOERRCODE 30
ISR_NOERRCODE 31

; --- Common Assembly Stub ---
; All ISRs jump here after pushing their number and a (optional) error code
extern fault_handler ; This is our C-level handler
isr_common_stub:
    pusha          ; Pushes edi,esi,ebp,esp,ebx,edx,ecx,eax

    mov ax, ds      ; Save the original data segment.
    push eax        ; Save it on the stack

    mov ax, 0x10    ; Load the kernel data segment descriptor
    mov ds, ax

    push esp          ; Push a pointer to the registers_t struct
    call fault_handler
    add esp, 4        ; Pop the pointer we pushed

    pop eax           ; Restore original data segment
    mov ds, ax        ; Restore ONLY the ds register. es, fs, gs were not manually saved,
                      ; so we don't restore them. Their original values are preserved
                      ; as part of the interrupted task's state.

    popa              ; Pop edi,esi,ebp,esp,ebx,edx,ecx,eax
    add esp, 8        ; Clean up the pushed error code and interrupt number
    iret              ; Return from interrupt
// myos/kernel/io.h

#ifndef IO_H
#define IO_H

void port_byte_out(unsigned short port, unsigned char data);
unsigned char port_byte_in(unsigned short port);
void pic_remap(int offset1, int offset2); // remapping interrupt vectors func

#endif; myos/kernel/kernel_entry.asm

bits 32         ; We are in 32-bit protected mode.

; These symbols are provided by the linker script
extern bss_start
extern bss_end

extern kmain    ; Tell NASM that kmain is defined in another file.

; Define the entry point for the linker.
global _start

_start:
    mov al, 'S'
    out 0xE9, al ; Checkpoint: Kernel Start

    ; The bootloader has jumped here directly.
    ; The only register that is properly set is CS.
    ; We must set up our data segments and stack now.
    mov ax, 0x10    ; 0x10 is the GDT_DATA selector from the bootloader's GDT
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    mov esp, 0x90000 ; Set up the stack pointer

    ; Crucial: Clear the direction flag.
    ; This ensures 'rep stosb' increments EDI, not decrements it.
    cld

    ; --- Clear the BSS section ---
    mov edi, bss_start      ; Destination address
    mov ecx, bss_end        ; Source address
    sub ecx, edi            ; The size of the BSS section
    xor eax, eax            ; Value to clear with (zero)
    rep stosb               ; Repeat store-byte ECX times

    mov al, 'B'
    out 0xE9, al ; Checkpoint: BSS cleared


    ; The bootloader has already set up the stack pointer (ESP).
    ; We can now safely call our main C function.
    mov al, 'C'
    out 0xE9, al ; Checkpoint: Calling C

    call kmain

    ; If kmain returns, hang the system. A real kernel's main
    ; loop should never exit.
    cli
    hlt
// myos/kernel/exceptions.c

#include "exceptions.h"
#include "vga.h" // for printing to screen

// C-level handler for all exceptions - now takes a pointer!
void fault_handler(registers_t *r) {
    clear_screen(); // Start with a clean slate
    print_string("CPU Exception Caught!\n\n");
    print_string("Interrupt Number: ");
    print_hex(r->int_no);
    print_string("\nError Code:       ");
    print_hex(r->err_code);
    print_string("\n\n-- Register Dump --\n");
    print_string("EIP: ");
    print_hex(r->eip);
    print_string("  CS: ");
    print_hex(r->cs);
    print_string("  EFLAGS: ");
    print_hex(r->eflags);
    print_string("\nESP: ");
    print_hex(r->esp);
    print_string("  EAX: ");
    print_hex(r->eax);
    print_string("\n\nSystem Halted.");

    // We hang forever.
    for (;;);
}// myos/kernel/vga.h

#ifndef VGA_H
#define VGA_H

#include "types.h" // to include uint32_t

void clear_screen();
void update_cursor(int row, int col);
void print_string(const char* str);
void print_hex(uint32_t n);

#endif// myos/kernel/idt.h
#ifndef IDT_H
#define IDT_H

#include "types.h"

// Defines a single entry in the Interrupt Descriptor Table (a "gate")
struct idt_entry_struct {
   uint16_t base_low;    // The lower 16 bits of the handler function's address
   uint16_t selector;    // The GDT code segment selector to use
   uint8_t  always0;     // This must always be zero
   uint8_t  flags;       // The gate type and attributes
   uint16_t base_high;   // The upper 16 bits of the handler function's address
} __attribute__((packed));


// Defines the structure for the IDT pointer, which is loaded using the 'lidt' instruction
struct idt_ptr_struct {
   uint16_t limit;       // The size of the IDT in bytes minus 1
   uint32_t base;        // The linear address where the IDT starts
} __attribute__((packed));

void idt_set_gate(uint8_t num, uint32_t base, uint16_t selector, uint8_t flags);
void idt_install();

#endif// myos/kernel/vga.c

#include "vga.h"
#include "io.h"
#include "types.h"

// Define a static cursor position
static int cursor_row = 0;
static int cursor_col = 0;

// Define the VGA buffer as a global, constant pointer to a volatile memory region.
volatile unsigned short* const VGA_BUFFER = (unsigned short*)0xB8000;

// Clear the screen by filling it with spaces
void clear_screen() {
    int i;
    for (int i = 0; i < 80 * 25; i++) {
        VGA_BUFFER[i] = (unsigned short)' ' | 0x0F00;
    }
}

// Updates the VGA cursor's position.
void update_cursor(int row, int col) {
    unsigned short position = (row * 80) + col;

    // Send the high byte of the cursor position
    port_byte_out(0x3D4, 0x0E);
    port_byte_out(0x3D5, (unsigned char)(position >> 8));
    // Send the low byte of the cursor position
    port_byte_out(0x3D4, 0x0F);
    port_byte_out(0x3D5, (unsigned char)(position & 0xFF));
}

void print_char(char c) {
    if (c == '\n') {
        cursor_row++;
        cursor_col = 0;
    } else {
        VGA_BUFFER[(cursor_row * 80) + cursor_col] = (VGA_BUFFER[(cursor_row * 80) + cursor_col] & 0xFF00) | c;
        cursor_col++;
    }

    if (cursor_col >= 80) {
        cursor_col = 0;
        cursor_row++;
    }
    update_cursor(cursor_row, cursor_col);
}

void print_string(const char* str) {
    int i = 0;
    while (str[i] != '\0') {
        print_char(str[i]);
        i++;
    }
}

void print_hex(uint32_t n) {
    print_string("0x");
    for (int i = 28; i >= 0; i -= 4) {
        uint32_t nibble = (n >> i) & 0xF;
        nibble += nibble > 9 ? 0x37 : 0x30;
        print_char((char)nibble);
    }
}// myos/kernel/types.h
#ifndef TYPES_H
#define TYPES_H

// Define fixed-width integer types for cross-platform compatibility
typedef unsigned char   uint8_t;
typedef unsigned short  uint16_t;
typedef unsigned int    uint32_t;
typedef unsigned long long uint64_t;

#endif/* myos/kernel/linker.ld */
ENTRY(_start)

SECTIONS {
    . = 0x10000; /* Kernel starts at 1MB */

    .text : {
        *(.text)
    }

    .rodata : {
        *(.rodata)
    }

    .data : {
        *(.data)
    }

    bss_start = .;
    .bss : {
        *(.bss)
    }
    bss_end = .;

    /* This section prevents the "executable stack" warning and cleans up output */
    /DISCARD/ : {
        *(.note.GNU-stack)
        *(.eh_frame)
    }
}# myos/Makefile
# A robust and scalable Makefile for myos

# Tell Make that these are not real files
.PHONY: all clean run

# --- Variables ---
BUILD_DIR := build
QEMU_CMD := qemu-system-i386
QEMU_OPTS := -fda $(BUILD_DIR)/os_image.bin -debugcon stdio

# --- Source Files ---
# Automatically find all .c and .asm source files
BOOT_SRC := boot/bootloader.asm
KERNEL_ASM_SRC := $(wildcard kernel/*.asm)
KERNEL_C_SRC := $(wildcard kernel/*.c)

# --- Object Files ---
# Generate the list of .o files from the source files
BOOT_OBJ := $(BUILD_DIR)/bootloader.bin
KERNEL_ASM_OBJ := $(patsubst kernel/%.asm, $(BUILD_DIR)/%.o, $(KERNEL_ASM_SRC))
KERNEL_C_OBJ := $(patsubst kernel/%.c, $(BUILD_DIR)/%.o, $(KERNEL_C_SRC))
ALL_KERNEL_OBJS := $(KERNEL_ASM_OBJ) $(KERNEL_C_OBJ)

# --- Final Binaries ---
KERNEL_ELF := $(BUILD_DIR)/kernel.elf
KERNEL_BIN := $(BUILD_DIR)/kernel.bin
DISK_IMAGE := $(BUILD_DIR)/os_image.bin

# --- Toolchain Flags ---
# Use NASM for assembly. -F dwarf creates debug symbols.
ASM := nasm
ASM_FLAGS := -f elf32 -F dwarf
# Use GCC for C. -g adds debug symbols.
CC := gcc
CFLAGS := -m32 -ffreestanding -nostdlib -fno-pie -fno-stack-protector -g -c
# Use LD for linking
LD := ld
LDFLAGS := -m elf_i386 -T kernel/linker.ld
# Use objcopy for extracting the binary
OBJCOPY := objcopy
OBJCOPY_FLAGS := -O binary

# --- Build Targets ---

# Default target: build everything
all: $(DISK_IMAGE)

# Rule to create the final disk image from the bootloader and kernel binary
$(DISK_IMAGE): $(BOOT_OBJ) $(KERNEL_BIN)
	@echo "Creating disk image: $@"
	@dd if=/dev/zero of=$@ bs=512 count=2880 >/dev/null 2>&1
	@dd if=$(BOOT_OBJ) of=$@ bs=512 seek=0 conv=notrunc >/dev/null 2>&1
	@dd if=$(KERNEL_BIN) of=$@ bs=512 seek=1 conv=notrunc >/dev/null 2>&1

# Rule to link all kernel objects into a single ELF file
$(KERNEL_ELF): $(ALL_KERNEL_OBJS)
	$(LD) $(LDFLAGS) -o $@ $^
	@echo "Kernel linked: $@"

# Rule to extract the raw binary from the ELF file
$(KERNEL_BIN): $(KERNEL_ELF)
	$(OBJCOPY) $(OBJCOPY_FLAGS) $< $@
	@echo "Kernel extracted to binary: $@"
	@echo -n "Kernel size: "
	@stat -c %s $@

# Rule to build the bootloader (special case, not an ELF object)
$(BOOT_OBJ): $(BOOT_SRC)
	@mkdir -p $(BUILD_DIR)
	$(ASM) $< -f bin -o $@

# Generic rule to compile any C source file to an object file
$(BUILD_DIR)/%.o: kernel/%.c
	@mkdir -p $(BUILD_DIR)
	$(CC) $(CFLAGS) $< -o $@

# Generic rule to assemble any kernel assembly file to an object file
$(BUILD_DIR)/%.o: kernel/%.asm
	@mkdir -p $(BUILD_DIR)
	$(ASM) $(ASM_FLAGS) $< -o $@

# Rule to run QEMU
run: $(DISK_IMAGE)
	@echo "Running OS in QEMU..."
	$(QEMU_CMD) $(QEMU_OPTS)

# Rule to clean up all build artifacts
clean:
	@echo "Cleaning build directory..."
	rm -rf $(BUILD_DIR)